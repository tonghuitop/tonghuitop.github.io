<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>作为前端人，谁没有自己的脚手架</title>
      <link href="/posts/917402534.html"/>
      <url>/posts/917402534.html</url>
      
        <content type="html"><![CDATA[<p>博主喜欢没事的时候，捣鼓一些小项目，博主还喜欢使用typescript，但每次要新搞一个项目时，都要配置一堆文件，例如<code>eslint</code>,<code>tsconfig</code>等文件。甚是麻烦。再说，前端人怎么可以没有自己的脚手架呢。</p><h3 id="项目期望"><a href="#项目期望" class="headerlink" title="项目期望"></a>项目期望</h3><ol><li>通过命令 ts-cli create <app name=""> 生成一个ts项目</app></li><li>根据选项，选择是否安装 <code>eslint</code>, <code>prettier</code>, <code>cz-conventional-changelog</code></li><li>自动配置好<code>typescript</code>, <code>eslint</code>, <code>prettier</code>, <code>cz</code>对应配置。</li></ol><h3 id="先手动手初始化配置一个tonghui-cli-项目"><a href="#先手动手初始化配置一个tonghui-cli-项目" class="headerlink" title="先手动手初始化配置一个tonghui-cli 项目"></a>先手动手初始化配置一个tonghui-cli 项目</h3><ol><li>初始化项目目录 并初始化git仓库<pre><code>mkdir tonghui-cli &amp;&amp; cd tonghui-clinpm init -y // 初始化package.jsongit init</code></pre>新增<code>.gitignore</code>文件, 设置忽略的文件<pre><code>node_modules/</code></pre></li></ol><ol start="2"><li>安装typescript, 并在根目录中添加tsconfig.json文件，并进行如下配置<pre><code>npm i typescript -Dnpm i @types/node -D // 安装 node.js 的类型定义包npm i ts-node-dev -D // 开发实时编译// tsconfig.json{"compileOnSave": true,"compilerOptions": { "target": "es2020", "module": "commonjs", "moduleResolution": "node", "experimentalDecorators": true, "emitDecoratorMetadata": true, "inlineSourceMap": true, "noImplicitThis": true, "noUnusedLocals": true, "stripInternal": true, "pretty": true, "declaration": true, "outDir": "lib", "baseUrl": "./", "paths": {   "*": ["src/*"] }},"exclude": ["lib", "node_modules", "test"]}</code></pre></li></ol><p><strong>修改package.json文件，添加ts自带编译脚本命令</strong></p><pre><code>"script": {  "build:comment": "构建",  "build": "npm run eslint &amp;&amp; npm run prettier &amp;&amp; rm -rf lib &amp;&amp; tsc --build",}</code></pre><p>更新<code>.gitignore</code>文件，新增忽略文件<code>lib</code></p><pre><code>node_modules/lib/</code></pre><ol start="3"><li>安装<code>eslint</code>，并配置<code>.eslintrc.json</code><blockquote><p>因为 TypeScript 关注的重心是类型的检查，而不是代码风格。所以我们通过<code>eslint</code>来进行语法的检查</p></blockquote><pre><code>npm i -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin// eslint: ESLint的核心代码// @typescript-eslint/parser：ESLint的解析器，用于解析typescript，从而检查和规范Typescript代码// @typescript-eslint/eslint-plugin：这是一个ESLint插件，包含了各类定义好的检测Typescript代码的规范</code></pre>在项目根目录中新建<code>.eslintrc.json</code>文件，配置eslint<pre><code>{"env": { "browser": true, "es2021": true, "node": true},"extends": [ "eslint:recommended", // 推荐的规则 "plugin:@typescript-eslint/recommended", // ts推荐的规则],"parser": "@typescript-eslint/parser",  // 解释器"parserOptions": { "ecmaVersion": 12, "sourceType": "module"},"plugins": [ "@typescript-eslint",],}</code></pre></li></ol><p><strong>修改package.json文件，添加类型检查脚本命令</strong></p><pre><code>"script": {  "eslint": "eslint --fix src --ext .ts --max-warnings=0",  "prettier:comment": "自动格式化 src 目录下的所有 .ts 文件",}</code></pre><ol start="4"><li>安装<code>prettier</code>, 并配置<code>.prettierrc.json</code><blockquote><p>Prettier中文的意思是漂亮的、美丽的。eslint可以检查出不规范的代码，prettier可以自动格式化为规范的代码</p></blockquote><pre><code>npm i -D prettier eslint-config-prettier eslint-plugin-prettier</code></pre>在项目根目录中新建<code>.prettierrc.json</code><pre><code>{"printWidth": 80,                   // 每一行的代码不能超过80"tabWidth": 2,                      // tab的宽度"useTabs": true,                    // 使用tab"singleQuote": true,                // 使用单引号代替双引"quoteProps": "as-needed",          // 当没有严格要求时，禁止对象字面量属性名称使用引号"semi": false,                      // 末尾分号"trailingComma": "none",            // 单行数组永远不会有尾随逗号"bracketSpacing": true,             // 大括号中间的空格"jsxBracketSameLine": true,         // 将&gt;多行 JSX 元素的 放在最后一行的末尾，而不是单独放在下一行"jsxSingleQuote": false,            // 在 JSX 中使用单引号代替双引号"arrowParens": "always",            // 在唯一的箭头函数参数周围包含括号"requirePragma": false,             // Prettier 可以将自身限制为仅在文件顶部包含称为 pragma 的特殊注释的格式文件。这在逐渐将大型无格式代码库过渡到 Prettier 时非常有用"insertPragma": false,              // Prettier 可以@format在文件顶部插入一个特殊标记，指定文件已使用 Prettier 格式化"proseWrap": "preserve",            // 默认情况下，Prettier 将按原样包装 Markdown 文本，因为某些服务使用对换行敏感的渲染器，例如 GitHub 评论和 BitBucket。"htmlWhitespaceSensitivity": "css", // 为 HTML、Vue、Angular 和 Handlebars 指定全局空白敏感度。"endOfLine": "lf"                 // 由于历史原因，文本文件中存在两种常见的行尾形式。即\n（或LF换行）和\r\n（或回车+CRLF换行）。}</code></pre></li></ol><p><strong>修改package.json文件，添加自动格式化代码命令</strong></p><pre><code>"script": {  "prettier:comment": "自动格式化 src 目录下的所有 .ts 文件",  "prettier": "prettier --write \"src/**/*.ts\"",}</code></pre><ol start="5"><li>安装<code>commitlint</code>,<blockquote><p>在系统开发中，如果 git 提交说明精准，在后期的协作以及 bug 处理时会变的有据可查，变相的提高了系统的可维护性，而且可以根据规范的提交说明快速生成开发日志，从而方便开发者或用户追踪项目的开发信息和功能特性。commitizen 是一个实现规范提交说明的工具。       </p></blockquote></li></ol><p><strong>使用 commitizen 在项目中生成符合 AngularJS 规范的提交说明，并初始化 cz-conventional-changelog 适配器</strong></p><pre><code>npx commitizen init cz-conventional-changelog --save --save-exact</code></pre><p>上面的命令为你做了三件事：</p><ol><li>安装 cz-conventional-changelog 适配器 npm 模块</li><li>将其保存到 package.json 的依赖项或 devDependencies</li><li>将config.commitizen密钥添加到package.json的根目录中，如下所示：<pre><code>"devDependencies": {"cz-conventional-changelog": "^3.3.0"},"config": {"commitizen": { "path": "cz-conventional-changelog"}}</code></pre><strong>接下来安装校验工具，负责校验提交信息是否符合规范</strong><pre><code>npm i @commitlint/cli @commitlint/config-conventional -D</code></pre><strong>在项目根目录下新建 commitlint.config.js 并设置校验规则</strong><pre><code>module.exports = {extends: ['@commitlint/config-conventional']}</code></pre><strong>修改package.json文件，添加使用规范化的提交信息脚本命令</strong><pre><code>"script": {"commit:comment": "引导设置规范化的提交信息","commit": "cz"}</code></pre></li></ol><ol start="6"><li>安装<code>husky</code>和<code>lint-staged</code><blockquote><p>husky: husky 是一个 Git Hook 工具<br>lint-staged: lint-staged 是一个在git暂存文件上运行linters的工具。<br>两者结合我们可以在git commit之前对git暂存文件进行lint检查和代码格式，而不需要对所有项目文件进行改动</p></blockquote><pre><code>npm i husky lint-staged -D</code></pre></li></ol><p><strong>修改package.json文件，添加lint-staged配置</strong></p><pre><code>"script": {  "commit:comment": "引导设置规范化的提交信息",  "commit": "cz"},"lint-staged": {  "*.ts": [    "npm run eslint",    "npm run prettier"  ]},</code></pre><p><strong>git hooks的设置</strong></p><pre><code>npx husky install // 生成一个 .husky 的文件夹npx husky add .husky/pre-commit "npx npx lint-staged"</code></pre><p>至此一个TS项目的初始化配置已经完成。包含已下功能过</p><ul><li>安装完成<code>typescript</code>，并设置好tsconfig.json文件</li><li>安装<code>eslint</code>, <code>prettier</code>, <code>cz</code>, <code>husky</code>等功能，并设置配置。   </li></ul><h3 id="ts-cli-脚手架"><a href="#ts-cli-脚手架" class="headerlink" title="ts-cli 脚手架"></a>ts-cli 脚手架</h3><blockquote><p>目前整个项目的搭建是我们手动搭建，下面正餐开始，开发脚手架，通过自动化的方式<code>ts-cli create ts-app</code>创建出我们配置半天的项目。</p></blockquote><h4 id="开发脚手架常用的第三方包"><a href="#开发脚手架常用的第三方包" class="headerlink" title="开发脚手架常用的第三方包"></a>开发脚手架常用的第三方包</h4><ul><li><p>commander</p><blockquote><p>完整的 node.js 命令行解决方案，灵感来自 Ruby 的 commander</p></blockquote></li><li><p>chalk</p><blockquote><p>粉饰你的终端，给你的终端文字添加样式</p></blockquote></li><li><p>shelljs</p><blockquote><p>让你在 node.js 中使用 unix shell 命令</p></blockquote></li><li><p>clear-console</p><blockquote><p>清空命令行</p></blockquote></li></ul><h4 id="本地npm包的调试。"><a href="#本地npm包的调试。" class="headerlink" title="本地npm包的调试。"></a>本地npm包的调试。</h4><ol><li>npm link的调试<blockquote><p>在本地开发npm模块的时候，我们可以使用npm link命令，将npm 模块链接到对应的运行项目中去，方便地对模块进行调试和测试</p></blockquote></li><li><code>package.json</code>中的<code>bin</code>字段<blockquote><p>bin项用来指定各个内部命令对应的可执行文件的位置</p></blockquote><pre><code>// package.json..."bin": {"ts-cli": "./bin/cli.js"},...</code></pre><blockquote><p>上面代码指定，ts-cli 命令对应的可执行文件为 bin 子目录下的 cli.js。Npm会寻找这个文件，在node_modules/.bin/目录下建立符号链接。在上面的例子中，cli.js会建立符号链接node_modules/.bin/ts-cli。所以执行ts-cli运行的是<code>./bin/cli.js</code>文件</p></blockquote></li></ol><h4 id="项目目录"><a href="#项目目录" class="headerlink" title="项目目录"></a>项目目录</h4><pre><code>// 自制脚手架目录├── bin│   └── cli.js  // 全局命令执行的根文件├── src│   ├── order│   │    └── cerate.ts 用户交互主程│   ├── utils   // 存放工具方法│   │    |___common.ts  // 存放基础的公共方法│   │    |___create.ts  // 用户交互命令的方法│   │    └── installFeature.ts // 安装单个feature的具体方法文件│   └── index.ts // 脚手架主命令流程 ├── .huskyrc    // git hook文件夹├── .eslintrc.json // eslint代码规范校├── .gitignore.json├── .prettierrc.json├── .commitlint.config.js├── tsconfig.json // ts配置文件├── package.json|__ README.md</code></pre><h5 id="src-utils-common-ts-基础的公共方法"><a href="#src-utils-common-ts-基础的公共方法" class="headerlink" title="src/utils/common.ts 基础的公共方法"></a>src/utils/common.ts 基础的公共方法</h5><pre><code>import { readFileSync, writeFileSync } from 'fs'import { resolve } from 'path'import * as clear from 'clear-console'export interface PackageJSON {  name: string  version: string  description: string  scripts: {    [key: string]: string  }  [key: string]: unknown}export interface JSON {  [key: string]: unknown}/** * 读取指定文件下 json 文件 * @param filename json 文件的路径 */export function readJsonFile&lt;T&gt;(filename: string): T {  return JSON.parse(readFileSync(filename, { encoding: 'utf-8', flag: 'r' }))}/** * 覆写指定路径下的 json 文件 * @param filename json 文件的路径 * @param content json 内容 */export function writeJsonFile&lt;T&gt;(filename: string, content: T): void {  writeFileSync(filename, JSON.stringify(content, null, 2), {    encoding: 'utf-8'  })}/** * 获取项目的绝对路径 * @param projectName 项目名称 */export function getProjectPath(projectName: string): string {  return resolve(process.cwd(), projectName)}/** * 打印信息 */export function printMsg(msg: string): void {  console.log(msg)}/** * 清空命令行 */export function clearConsole(): void {  clear()}</code></pre><h5 id="src-utils-installFeature-ts-安装eslint等第三方包，后期可扩展"><a href="#src-utils-installFeature-ts-安装eslint等第三方包，后期可扩展" class="headerlink" title="src/utils/installFeature.ts 安装eslint等第三方包，后期可扩展"></a>src/utils/installFeature.ts 安装<code>eslint</code>等第三方包，后期可扩展</h5><pre><code>/** * 安装包的方法 */import * as shell from 'shelljs'import { writeFileSync } from 'fs'import { red } from 'chalk'import { PackageJSON, printMsg, readJsonFile, writeJsonFile } from './common'/** * 安装ESLint */function installESLint(): void {  shell.exec(    'npm i eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-prettier -D'  )  // 添加 eslintrc.json  const eslintrc = `{    "env": {      "es2021": true,      "node": true,      "browser": true,    },    "extends": [      "eslint:recommended",      "plugin:@typescript-eslint/recommended",      "plugin:prettier/recommended"    ],    "parser": "@typescript-eslint/parser",    "parserOptions": {      "ecmaVersion": 12,      "sourceType": "module"    },    "plugins": [      "@typescript-eslint"      "prettier" //  eslint 会使用pretter的规则对代码格式化    ],    "rules": {      "prettier/prettier": 2, // 对于不符合prettier规范的写法，eslint会提示报错      "spaced-comment": [2, "always"] // 注释后面必须写两个空格    }  }`  try {    writeFileSync('./.eslintrc.json', eslintrc, { encoding: 'utf-8' })  } catch (err) {    printMsg(`${red('Failed to write .eslintrc.json file content')}`)    printMsg(`${red('Please add the following content in .eslintrc.json')}`)    printMsg(`${red(eslintrc)}`)  }  // 修改package.json  const packageJson = readJsonFile&lt;PackageJSON&gt;('./package.json')  packageJson.scripts['eslint:comment'] =    '使用 ESLint 检查并自动修复 src 目录下所有扩展名为 .ts 的文件'  packageJson.scripts['eslint'] = 'eslint --fix src --ext .ts --max-warnings=0'  writeJsonFile&lt;PackageJSON&gt;('./package.json', packageJson)}/** * 安装 Prettier */function installPrettier(): void {  // 安装 prettier 和 prettier与ESlint的插件  shell.exec('npm i prettier -D')  // 添加 prettier.json  const prettierrc = `{    // 一行最多 80 字符    "printWidth": 80,    // 使用 2 个空格缩进    "tabWidth": 2,    // 不使用 tab 缩进，而使用空格    "useTabs": false,    // 行尾需要有分号    "semi": false,    // 使用单引号代替双引号    "singleQuote": true,    // 对象的 key 仅在必要时用引号    "quoteProps": "as-needed",    // jsx 不使用单引号，而使用双引号    "jsxSingleQuote": false,    // 末尾不实用逗号    "trailingComma": "none",    // 大括号内的首尾需要空格 { foo: bar }    "bracketSpacing": true,    // jsx 标签的反尖括号需要换行    "jsxBracketSameLine": true,    // 箭头函数，只有一个参数的时候，也需要括号    "arrowParens": "always",    // 不需要写文件开头的 @prettier    "requirePragma": false,    // 不需要自动在文件开头插入 @prettier    "insertPragma": false,    // 使用默认的折行标准    proseWrap: 'preserve',    // 根据显示样式决定 html 要不要折行    htmlWhitespaceSensitivity: 'css',    // 换行符使用 lf    endOfLine: 'lf'  }`  try {    writeFileSync('./.prettierrc.json', prettierrc, { encoding: 'utf-8' })  } catch (err) {    printMsg(`${red('Failed to write .prettierrc.json file content')}`)    printMsg(`${red('Please add the following content in .prettierrc.json')}`)    printMsg(`${red(prettierrc)}`)  }  // 修改package.json  const packageJson = readJsonFile&lt;PackageJSON&gt;('./package.json')  packageJson.scripts['prettier:comment'] =    '自动格式化 src 目录下的所有 .ts 文件'  packageJson.scripts['prettier'] = 'prettier --write "src/**/*.ts"'  writeJsonFile&lt;PackageJSON&gt;('./package.json', packageJson)}/** * 安装 CZ，规范 git 提交信息 */function installCZ(): void {  shell.exec(    'npx commitizen init cz-conventional-changelog --save --save-exact'  )  shell.exec('npm i @commitlint/cli @commitlint/config-conventional -D')  // 添加 commitlint.config.js  const commitlint = `module.exports = {    extends: ['@commitlint/config-conventional']  }`  try {    writeFileSync('./commitlint.config.js', commitlint, { encoding: 'utf-8' })  } catch (err) {    printMsg(`${red('Failed to write .commitlint.config.js file content')}`)    printMsg(      `${red('Please add the following content in .commitlint.config.js')}`    )    printMsg(`${red(commitlint)}`)  }  // 改写 package.json  const packageJson = readJsonFile&lt;PackageJSON&gt;('./package.json')  packageJson.scripts['commit:comment'] = '引导设置规范化的提交信息'  packageJson.scripts['commit'] = 'cz'  writeJsonFile&lt;PackageJSON&gt;('./package.json', packageJson)}/** * 安装 husky 和 lint-staged，以实现 git commit 时自动化校验 * @param hooks，需要自动执行的钩子 * @param lintStaged，需要钩子运行的命令 */function installHusky(  hooks: { [key: string]: string },  lintStaged: Array&lt;string&gt;): void {  // 初始化 git 仓库  shell.exec('git init')  // 在安装 husky 和 lint-staged  shell.exec('npm i husky lint-staged -D')  // 设置 package.json  const packageJson = readJsonFile&lt;PackageJSON&gt;('./package.json')  packageJson['lint-staged'] = {    '*.ts': lintStaged.map((item) =&gt; `npm run ${item}`)  }  writeJsonFile&lt;PackageJSON&gt;('./package.json', packageJson)  shell.exec(    'npx husky install &amp;&amp; npx husky add .husky/pre-commit "npx lint-staged"'  )}/** * 安装构建工具，目前主要用于小项目，所以使用 typescript 原生的构建功能即可 * @param feature 已安装的包 */function installBuild(feature: Array&lt;string&gt;): void {  // 设置 package.json  const packageJson = readJsonFile&lt;PackageJSON&gt;('./package.json')  packageJson.scripts['build:comment'] = '构建'  let order = ''  if (feature.includes('ESLint')) {    order += 'npm run eslint'  }  if (feature.includes('Prettier')) {    order += ' &amp;&amp; npm run prettier'  }  order += ' &amp;&amp; rm -rf lib &amp;&amp; tsc --build'  packageJson.scripts['build'] = order  writeJsonFile&lt;PackageJSON&gt;('./package.json', packageJson)}export default {  installESLint,  installPrettier,  installCZ,  installHusky,  installBuild}</code></pre><h5 id="src-utils-create-ts"><a href="#src-utils-create-ts" class="headerlink" title="src/utils/create.ts"></a>src/utils/create.ts</h5><pre><code>/** * create 命令需要用到的所有方法 */import {  JSON,  printMsg,  PackageJSON,  clearConsole,  readJsonFile,  writeJsonFile,  getProjectPath} from './common'import { existsSync } from 'fs'import { prompt } from 'inquirer'import { blue, cyan, gray, red, yellow } from 'chalk'import * as shell from 'shelljs'import installFeatureMethod from './installFeature'/** * 验证当前目录下是否已经存在指定文件，如果存在则退出进行 * @param filename 文件名 */export function isFileExist(filename: string): void {  // 文件路径  const file = getProjectPath(filename)  if (existsSync(file)) {    printMsg(red(`${file} 文件已存在`))    process.exit(1)  }}/** * 交互式命令行，让用户自己选择需要的功能 */export async function selectFeature(): Promise&lt;Array&lt;string&gt;&gt; {  // 清空命令行  clearConsole()  // 输出信息  // eslint-disable-next-line @typescript-eslint/no-var-requires  printMsg(blue(`TS CLI v${require('../../package.json').version}`))  printMsg('Start initializing the project:')  printMsg('')  // 选择功能，这里配合 下面的 installFeature 方法 和 ./installFeature.ts 文件为脚手架提供了良好的扩展机制  // 将来扩展其它功能只需要在 choices 数组中增加配置项，然后在 ./installFeature.ts 文件中增加相应的安装方法即可  const { feature } = await prompt([    {      name: 'feature',      type: 'checkbox',      message: 'Check the features needed for your project',      choices: [        { name: 'ESLint', value: 'ESLint' },        { name: 'Prettier', value: 'Prettier' },        { name: 'CZ', value: 'CZ' }      ]    }  ])  return feature as Array&lt;string&gt;}/** * 初始化项目目录 */export function initProjectDir(projectName: string): void {  shell.exec(`mkdir ${projectName}`)  shell.cd(projectName)  shell.exec('npm init -y')}/** * 改写项目中 package.json 的 name */export function changePackageInfo(projectName: string): void {  const packageJSON: PackageJSON = readJsonFile&lt;PackageJSON&gt;('./package.json')  packageJSON.name = packageJSON.description = projectName  writeJsonFile('./package.json', packageJSON)}/** * 安装 typescript 并初始化 */export function installTSAndInit(): void {  shell.exec('npm i typescript -D &amp;&amp; npx tsc --init')  const tsconfigJson: JSON = {    compileOnSave: true,    compilerOptions: {      target: 'ES2018',      module: 'ESNext',      moduleResolution: 'node',      experimentalDecorators: true,      emitDecoratorMetadata: true,      inlineSourceMap: true,      noImplicitThis: true,      noUnusedLocals: true,      stripInternal: true,      pretty: true,      declaration: true,      outDir: 'lib',      baseUrl: './',      strict: true,      forceConsistentCasingInFileNames: true    },    exclude: ['lib', 'node_modules']  }  try {    writeJsonFile('./tsconfig.json', tsconfigJson)  } catch (err) {    printMsg(red('Failed to write tsconfig.json file content'))    printMsg(red('Please add the following content in tsconfig.json'))    printMsg(red(tsconfigJson))    shell.exec('mkdir src &amp;&amp; touch src/index.ts')  }}/** * 安装 @types/node * 这是 node.js 的类型定义包 */export function installTypesNode(): void {  shell.exec('npm i @types/node -D')}/** * 安装开发环境，支持实时编译 */export function installDevEnvironment(): void {  shell.exec('npm i ts-node-dev -D')  // 修改package.json 文件  const packageJson = readJsonFile&lt;PackageJSON&gt;('./package.json')  packageJson.scripts['dev:comment'] = '启动开发编译'  packageJson.scripts['dev'] = 'ts-node-dev --respawn --transpile-only index.ts'  writeJsonFile('./package.json', packageJson)}/** * 安装用户选择的功能 * @param feature 户选择的功能列表 */export function installFeature(feature: Array&lt;string&gt;): void {  feature.forEach((item) =&gt; {    const featureFuncName =      `install${item}` as keyof typeof installFeatureMethod    const func = installFeatureMethod[featureFuncName] as () =&gt; void    func()  })  // 安装 husky 和 lint-staged  installHusky(feature)  // 安装构建工具  installFeatureMethod.installBuild(feature)}/** * 安装 husky 和 lint-staged，并根据功能设置相关命令 * @param feature 户选择的功能列表 */function installHusky(feature: Array&lt;string&gt;): void {  // 副本  const featureBak = Object.assign([], feature)  // 设置hook  const hooks: { [key: string]: string } = {}  // 判断用户是否选择了CZ，有则这是hooks  if (featureBak.includes('CZ')) {    hooks['commit-msg'] = 'commitlint -E HUSKY_GIT_PARAMS'  }  // 设置lintStaged  const lintStaged: Array&lt;string&gt; = []  if (featureBak.includes('ESLint')) {    lintStaged.push('eslint')  }  if (featureBak.includes('Prettier')) {    lintStaged.push('prettier')  }  installFeatureMethod.installHusky(hooks, lintStaged)}/** * 整个项目安装结束，给用户提示信息 */export function end(projectName: string): void {  printMsg(`Successfully create project ${yellow(projectName)}`)  printMsg('Get started with the following commands')  printMsg('')  printMsg(`${gray('$')} ${cyan('cd ' + projectName)}`)  printMsg(`${gray('$')} ${cyan('npm run dev')}`)  printMsg('')}</code></pre><h5 id="src-order-create-ts"><a href="#src-order-create-ts" class="headerlink" title="src/order/create.ts"></a>src/order/create.ts</h5><pre><code>/** * create 命令行的具体任务 */import {  isFileExist,  selectFeature,  initProjectDir,  changePackageInfo,  installTSAndInit,  installTypesNode,  installDevEnvironment,  installFeature,  end} from '../utils/create'export default async function create(projectName: string): Promise&lt;void&gt; {  // 判断文件是否存在  isFileExist(projectName)  // 选择需要的功能  const feature = await selectFeature()  // 初始化项目目录  initProjectDir(projectName)  // 改写项目的 package.json 基本信息，比如 name  changePackageInfo(projectName)  // 安装 typescript 并初始化  installTSAndInit()  // 安装 @types/node  installTypesNode()  // 安装开发环境，支持实时编译  installDevEnvironment()  // 安装 feature  installFeature(feature)  // 结束  end(projectName)}</code></pre><h5 id="src-index-ts"><a href="#src-index-ts" class="headerlink" title="src/index.ts"></a>src/index.ts</h5><pre><code>import { program } from 'commander'import create from './order/create'program  // eslint-disable-next-line @typescript-eslint/no-var-requires  .version(`${require('../package.json').version}`, '-v --version')  .usage('&lt;command&gt; [options]')program  .command('create &lt;app-name&gt;')  .description('Create new project from =&gt; ts-cli create yourProjectName')  .action(async (name: string) =&gt; {    await create(name)  })program.parse(process.argv)</code></pre><h5 id="bin-cli-js"><a href="#bin-cli-js" class="headerlink" title="bin/cli.js"></a>bin/cli.js</h5><pre><code>#!/usr/bin/env noderequire('../lib/index')</code></pre><h3 id="构建与测试"><a href="#构建与测试" class="headerlink" title="构建与测试"></a>构建与测试</h3><pre><code>❯ yarn build❯ npm link❯ ../ts-cli create test-ts-app</code></pre><h3 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h3><ol><li>整理<code>package.json</code>信息<pre><code>{"name": "@tonghui/ts-cli","main": "./lib/index.js","keywords": [ "typescript", "cli", "ts-cli", "ts 脚手架", "typescript 脚手架"],"version": "1.0.2","description": "typescript 项目脚手架","bin": { "ts-cli": "./bin/cli.js"},"files": [ "package.json", "README.md", "lib"],"scripts": { ...},"repository": { "type": "git", "url": "https://github.com/tonghuitop/ts-cli"},"lint-staged": { "*.ts": [   "npm run eslint",   "npm run prettier" ]},"author": "tonghui","license": "ISC",...}</code></pre></li></ol><p><strong>在项目根目录下增加一个发布脚本 publish.sh</strong></p><pre><code>#!/bin/bashecho '开始构建脚手架'npm run buildecho '脚手架构建完成，现在发布'npm publish --access public</code></pre><ol><li>登陆npm<pre><code>npm login</code></pre></li><li>执行发布脚本<pre><code>sh publish.sh</code></pre></li></ol><h3 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h3><ol><li>当前项目已发布到<code>npm</code>平台： <a href="https://www.npmjs.com/package/@tonghui/ts-cli" target="_blank" rel="noopener">https://www.npmjs.com/package/@tonghui/ts-cli</a></li><li>当前项目github链接，欢迎start: <a href="https://github.com/tonghuitop/ts-cli" target="_blank" rel="noopener">https://github.com/tonghuitop/ts-cli</a></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
          <category> TypeScript </category>
          
          <category> cli </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> TypeScript </tag>
            
            <tag> 脚手架 </tag>
            
            <tag> cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写简易版redux</title>
      <link href="/posts/2294066012.html"/>
      <url>/posts/2294066012.html</url>
      
        <content type="html"><![CDATA[<h3 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h3><h5 id="订阅发布模式"><a href="#订阅发布模式" class="headerlink" title="订阅发布模式"></a>订阅发布模式</h5><blockquote><p>发布订阅模式：一群订阅者（Subscriber）通过消息调度中心来实现基于某个主题去订阅发布者（Publisher）,当有关状态发生变化时，Publisher会基于某个主题去通知该主题下对应的订阅者（Subscriber）触发更新。相比于上面的观察者模式而言，能够实现发布者与订阅者之间的解耦，而且能基于不同主题来添加订阅者，从而实现更为颗粒度的控制。</p></blockquote><pre><code>type callbackType = (options?: any) =&gt; voidclass Event {  private listeners: Map&lt;string, Array&lt;callbackType&gt;&gt; = new Map()  // 订阅事件  subscribe(key: string, callback: callbackType) {    if (typeof callback !== 'function') {      return    }    const currentListeners = this.listeners.get(key)    if(Array.isArray(currentListeners)) {      this.listeners.set(key, [...currentListeners, callback])    } else {      this.listeners.set(key, [callback])    }  }  // 发布事件  publish(key: string, options?: any) {    const currentListeners = this.listeners.get(key)    if (!currentListeners) {       return    }    currentListeners.forEach((callback) =&gt; {      callback(options)    })  }  // 移出已订阅事件  remove(key: string, callback: callbackType): boolean {    const currentListeners = this.listeners.get(key)    if(!currentListeners || !callback) {      return false    }    const newListeners = currentListeners.filter(        (listenerCallback) =&gt; listenerCallback !== callback      )    if (newListeners.length &gt; 0) {      this.listeners.set(key, newListeners)    } else {      this.listeners.delete(key)    }    return true  }}</code></pre><h4 id="函数式编程之Compose函数"><a href="#函数式编程之Compose函数" class="headerlink" title="函数式编程之Compose函数"></a>函数式编程之Compose函数</h4><blockquote><p><code>compose</code> 函数可以接收多个独立的函数作为参数，然后将这些函数进行组合串联，最终返回一个“组合函数”。<br>例如执行：相当于将层级函数，给拍平了。</p></blockquote><pre><code>function compose (f1, f2, f3, f4) {  return (args) =&gt; f1(f2(f3(f4(args)))}</code></pre><p><strong>特点：</strong></p><ul><li>参数是多个函数，返回值是一个“组合函数”。</li><li>组合函数内的所有的函数从右至左一个一个执行（主要符合数学从右到左的操作概念）。</li><li>组合函数内除了第一个执行函数的参数是多元的，其它函数的参数都是接收上一个函数的返回值。<pre><code>function sum (x, y) {return x + y}function square(x) {return x**2}// 没有使用composeconst rust = (x, y) =&gt; square(sum(x, y)) // 使用composeconst rust = compose(square, sum)</code></pre>所以先判断有多少个函数，然后递归执行函数，每次一个函数执行完成后，返回执行结果<pre><code>// 使用es6的结构获取参数数组，其应该是传入的函数参数function compose(...arr) {const len = arr.length// 函数是从最里面的函数开始执行，即从右执行let runIndex = len - 1return function recursion () {  const result = arr[runIndex].apply(this, arguments)  // 不满足运行条件  if (runIndex &lt;= 0) {    runIndex = len - 1    return result  }  runIndex--  return recursion.call(this, result)}}</code></pre></li></ul><p><strong>使用es6数组的reducer方法后，更简洁的方法</strong></p><pre><code>function compose(...arr) {  if (arr.length === 0) {    return arg =&gt; arg  }  if (arr.length === 1) {    return arr[0]  }  // ES6 方式的重点就是利用了数组的 reduce 合并功能， 每次遍历合并都会将上一次组合后的函数返回回来再与当前的函数参数进行组合。依次不断的累积组合，最终返回这个组合函数。  return arr.reduce((a, b) =&gt; (...args) =&gt; a(b(...args)));}</code></pre><h3 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h3><h4 id="Redux的设计思想"><a href="#Redux的设计思想" class="headerlink" title="Redux的设计思想"></a>Redux的设计思想</h4><p>Redux是一个前端状态管理库。说到redux，不得不说一说flux。Flux是Facebook用于构建客户端Web应用程序的基本架构，我们可以将Flux看做一种应用程序中的数据流的设计模式，而Redux正是基于Flux的核心思想实现的一套解决方案，它也得到了原作者的肯定。</p><p>首先，在Flux中会有以下角色：</p><ul><li>Dispatcher: 调度器，收到Action，并将它发给store</li><li>Action: 动作消息，包含动作类型与动作描述</li><li>Store: 数据中心，持有应用程序的数据，并会响应Action消息</li><li>View: 应用视图，可展示Store数据，并实时响应Store的更新<br>从通讯的角度还可将其视为Action请求层 -&gt; Dispatcher传输层 -&gt; Store处理层 -&gt; View视图层</li></ul><p>Flux应用中的数据以单一方向流动：</p><ol><li>视图产生动作消息，将动作传递给调度器。   </li><li>调度器将动作消息发送给每一个数据中心。    </li><li>数据中心再将数据传递给视图。   </li></ol><p>单向数据流具有以下特点：</p><ul><li>集中化管理数据。常规应用可能会在视图层的任何地方或回调进行数据状态的修改与存储，而在Flux架构中，所有数据都只放在Store中进行储存与管理。</li><li>可预测性。在双向绑定或响应式编程中，当一个对象改变时，可能会导致另一个对象发生改变，这样会触发多次级联更新。对于Flux架构来讲，一次Action触发，只能引起一次数据流循环，这使得数据更加可预测。</li><li>方便追踪变化。所有引起数据变化的原因都可由Action进行描述，而Action只是一个纯对象，因此十分易于序列化或查看。</li></ul><h4 id="开始手写一个my-redux—本次项目使用TS开发"><a href="#开始手写一个my-redux—本次项目使用TS开发" class="headerlink" title="开始手写一个my-redux—本次项目使用TS开发"></a>开始手写一个my-redux—本次项目使用TS开发</h4><ol><li><p>初始化项目</p><ul><li>创建项目文件夹 mkdir myRedux</li><li>安装依赖 npm run @types/node tslint typescript -D</li><li>设置tsconfig配置 tsc –init，生成tsconfig.json文件<blockquote><p>{<br> “compilerOptions”: {<br>   “lib”: [“ES2015”],<br>   “module”: “commonjs”,<br>   “outDir”: “dist”,<br>   “sourceMap”: true,<br>   “strict”: true,<br>   “target”: “es2015”,<br> },<br> “include”: [<br>   “src”<br> ]<br>}</p></blockquote></li><li>创建项目目录，已及配置package中的脚本<ul><li><img src="/img/redux/src.png" alt="index"></li></ul></li></ul></li><li><p>创建createStore方法<br>在原redux中，我们的使用方法是</p><pre><code>import { createStore } from 'redux';const initState = { milk: 0};function reducer(state = initState, action) { switch (action.type) {   case 'PUT_MILK':     return {...state, milk: state.milk + action.payload.count}     case 'TAKE_MILK':       return {...state, milk: state.milk - action.payload.count}   default:     return state }}let store = createStore(reducer);// subscribe其实就是订阅store的变化，一旦store发生了变化，传入的回调函数就会被调用// 如果是结合页面更新，更新的操作就是在这里执行store.subscribe(() =&gt; console.log(store.getState()));// 将action发出去要用dispatchstore.dispatch({ type: 'PUT_MILK', payload: {count: 1 }});    // milk: 1store.dispatch({ type: 'PUT_MILK', payload: {count: 1 }});    // milk: 2store.dispatch({ type: 'TAKE_MILK', payload: {count: 1 }});   // milk: 1</code></pre><p><strong>接下来我们自己实现</strong><br>从上面看，我们主要使用了createStore，这个api，传入的参数主要是，reducer，返回的是一个store，store上有subscribe,dispatch,getState等api</p><ul><li><p>store.subscribe: 订阅state的变化，当state变化的时候执行回调，可以有多个subscribe，里面的回调会依次执行。</p></li><li><p>store.dispatch: 发出action的方法，每次dispatch action都会执行reducer生成新的state，然后执行subscribe注册的回调。—这里是不是我们前面讲的订阅发布呢</p></li><li><p>store.getState:一个简单的方法，返回当前的state。</p><pre><code>function createStore(reducer: reducerType) {let state: any  // 记录状态let listeners: Array&lt;() =&gt; void&gt; = []  // 保持所有注册的回调// 订阅事件function subscribe(callback: () =&gt; any) { listeners.push(callback)}// dispatch 就是将所有的回调拿出来依次执行function dispatch(action: any) { state = reducer(state, action) for (let i = 0; i &lt; listeners.length; i++) {   const listener = listeners[i]   listener() }}function getState() { return state}const store = { subscribe, dispatch, getState}return store}</code></pre><p><img src="/img/redux/logo.png" alt="console"></p></li></ul><ol start="3"><li><p>添加<strong>combineReducers</strong>方法<br>当项目中的store树过于庞大的时候，例如在一个复杂网站编辑器的web项目中，需要有关于域名设置的store，关于商店的store，关于网站设置的store。<br>实际调用时</p><pre><code>const reducer = combineReducers({milk: milkReducer, rice: riceReducer})</code></pre><p>分析得到，combineReducers方法，就是输入多个reducer，输入一个普通的reducer，</p><pre><code>function combineReducers(reducerMap: {[key: string]: any}) {const reducerKeys = Object.keys(reducerMap)// 转化为一个普通结构的reducer对象const reducer = (state:any = {}, action: any) =&gt; {// 整合storeconst newState:any = {}// 循环便利执行所有的reducefor (let i = 0; i &lt; reducerKeys.length; i++) {  const key = reducerKeys[i]  const currentReducer = reducerMap[key]  const prevState = state[key]  newState[key] = currentReducer(prevState, action)}return newState}return reducer}</code></pre><p>测试</p><pre><code>function milkReducer (state = initState, action: any) {switch (action.type) {case 'PUT_MILK':  return {...state, milk: state.milk + action.payload.count}  case 'TAKE_MILK':    return {...state, milk: state.milk - action.payload.count}default:  return state}}const initRiceState = {rice: 0}function riceReducer (state = initRiceState, action: any) {switch (action.type) {case 'PUT_RICE':  return {...state, milk: state.rice + action.payload.count}  case 'TAKE_RICE':    return {...state, milk: state.rice - action.payload.count}default:  return state}}const reducer = combineReducers({milk: milkReducer, rice: riceReducer})let store = createStore(reducer, applyMiddleware(logger))store.subscribe(() =&gt; console.log(store.getState()))store.dispatch({ type: 'PUT_MILK', payload: {count: 1 }});    // milk: 1store.dispatch({ type: 'PUT_MILK', payload: {count: 1 }});    // milk: 2store.dispatch({ type: 'TAKE_MILK', payload: {count: 1 }});   // milk: 1</code></pre><p>输入</p><pre><code>➜  myRedux git:(main) ✗ yarn devyarn run v1.22.4$ ./node_modules/.bin/tsc &amp;&amp; node ./dist/index.jsPUT_MILKdispatching { type: 'PUT_MILK', payload: { count: 1 } }{ milk: { milk: 1 }, rice: { rice: 0 } }next state { milk: { milk: 1 }, rice: { rice: 0 } }PUT_MILKdispatching { type: 'PUT_MILK', payload: { count: 1 } }{ milk: { milk: 2 }, rice: { rice: 0 } }next state { milk: { milk: 2 }, rice: { rice: 0 } }TAKE_MILKdispatching { type: 'TAKE_MILK', payload: { count: 1 } }{ milk: { milk: 1 }, rice: { rice: 0 } }next state { milk: { milk: 1 }, rice: { rice: 0 } }✨  Done in 2.48s.</code></pre></li><li><p>添加applyMiddleware方法<br>先看一下手写的logger middleware，已及调用结果</p><pre><code>import { storeType } from './type'function logger(store: storeType) {/*** next === dispatch方法，next为old dispatch的装饰器方法*/return function(next: any) {  // 返回一个新的dispatch，增强了dispatch  return function(action: any) {    console.group(action.type);    console.info('dispatching', action);    let result = next(action);    console.log('next state', store.getState());    console.groupEnd();    return result  }}}export default logger...let store = createStore(reducer, applyMiddleware(logger))...</code></pre><ol><li>createStore方法的修改，我们看到createStore方法新增了第二个参数，这个参数官方称为enhancer，顾名思义他是一个增强器，用来增强store的能力的。官方对于enhancer的定义如下：<pre><code>type StoreEnhancer = (next: StoreCreator) =&gt; StoreCreator</code></pre>上面的结构的意思是说enhancer作为一个函数，他接收StoreCreator函数作为参数，同时返回的也必须是一个StoreCreator函数。注意他的返回值也是一个StoreCreator函数，也就是我们把他的返回值拿出来继续执行应该得到跟之前的createStore一样的返回结构，也就是说我们之前的createStore返回啥结构，他也必须返回哈结构。       </li></ol><p><strong>修改createStore方法：</strong></p><pre><code>function createStore(reducer: reducerType, enhancer?: enhancerType) {let state: any  // 记录状态let listeners: Array&lt;() =&gt; void&gt; = []  // 保持所有注册的回调if (enhancer &amp;&amp; typeof enhancer === 'function') {  const newCreateStore = enhancer(createStore)  const newStore = newCreateStore(reducer)  return newStore}...</code></pre><ol start="2"><li>可以看到我们let result = next(action);这行执行之后state改变了，前面我们说了要改变state只能dispatch(action)，所以这里的next(action)就是dispatch(action)，只是换了一个名字而已。而且注意最后一层返回值return function(action)的结构，他的参数是action，是不是很像dispatch(action)，其实他就是一个新的dispatch(action)，这个新的dispatch(action)会调用原始的dispatch，并且在调用的前后加上自己的逻辑。所以到这里一个中间件的结构也清楚了。</li></ol><ul><li>中间件接收store作为参数，会返回一个函数</li><li>返回的这个函数接收老的dispatch函数作为参数，会返回一个新的函数</li><li>返回的新函数就是新的dispatch函数，这个函数里面可以拿到外面两层传进来的store和老dispatch函数</li></ul><p><strong>注：</strong>这里就是设计模式中的装饰者模式，也是koa的AOP面向切片编程的一种事件<br>下面来实现我们的applyMiddleware</p><pre><code>function applyMiddleware(middleware) {  function enhancer(createStore) {    // 返回一个新增的createStore    function newCreateStore(reducer) {      const store = createStore(reducer)      // dispatch的装饰器      const decoratorDispatch = middleware(store)      const { dispatch } = store      const newDispatch = decoratorDispatch(dispatch)      return {...store, dispatch: newDispatch}    }    return newCreateStore  }  return enhancer}</code></pre><p>方法的测试在上方的输出已经验证过了</p><ol start="3"><li>增强applyMiddleware方法，多个中间件的情况下怎么过work。<pre><code>let store = createStore(reducer, applyMiddleware(logger, logger2))</code></pre>前面我们说过了，middleware(store),返回的是增强过的dispatch,但还是一个dispatch，每个middleware都是接受store和dispatch，所以多个中间应该是decoratorDispatch4(decoratorDispatch3(decoratorDispatch2(decoratorDispatch(dispatch))))，此时就用到了我们前面将的compose<pre><code>// 多个middleware，先解构出dispatch =&gt; newDispatch的结构const decorators = middlewares.map(middleware =&gt; middleware(store))// 用compose得到一个组合了所有newDispatch的函数const newDispatchGen = compose(...decorators)// 执行这个函数得到newDispatchconst newDispatch = newDispatchGen(dispatch)</code></pre>完成的applyMiddleware方法：<pre><code>function applyMiddleware(...middlewares: Array&lt;any&gt;) {function enhancer(createStore: createStoreType) { function newCreateStore(reducer: reducerType) {   const store = createStore(reducer);   const { dispatch } = store;   // 多个middleware，先解构出dispatch =&gt; newDispatch的结构   const decorators = middlewares.map(middleware =&gt; middleware(store));   // 用compose得到一个组合了所有newDispatch的函数   const newDispatchGen = compose(...decorators)   // 执行这个函数得到newDispatch   const newDispatch = newDispatchGen(dispatch)   return {...store, dispatch: newDispatch} } return newCreateStore;}return enhancer;}</code></pre></li></ol><p><strong>测试：</strong></p><pre><code>yarn run v1.22.4$ ./node_modules/.bin/tsc &amp;&amp; node ./dist/index.jsPUT_MILK  dispatching { type: 'PUT_MILK', payload: { count: 1 } }  { milk: { milk: 1 }, rice: { rice: 0 } }  logger2  next state { milk: { milk: 1 }, rice: { rice: 0 } }PUT_MILK  dispatching { type: 'PUT_MILK', payload: { count: 1 } }  { milk: { milk: 2 }, rice: { rice: 0 } }  logger2  next state { milk: { milk: 2 }, rice: { rice: 0 } }TAKE_MILK  dispatching { type: 'TAKE_MILK', payload: { count: 1 } }  { milk: { milk: 1 }, rice: { rice: 0 } }  logger2  next state { milk: { milk: 1 }, rice: { rice: 0 } }✨  Done in 2.82s.</code></pre><p>完成！！！</p></li></ol></li></ol><h4 id="函数柯立化"><a href="#函数柯立化" class="headerlink" title="函数柯立化"></a>函数柯立化</h4><p>最后分享一个小知识，在该项目的<code>compose</code>方法边写时，一时想到了<code>函数柯立化</code>,故记录下来，分享。</p><blockquote><p>维基百科：在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。<br>柯里化（Currying）是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。<br>柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。<br>柯里化不会调用函数。它只是对函数进行转换。</p></blockquote><pre><code>function curry(f) { // curry(f) 执行柯里化转换  return function(a) {    return function(b) {      return f(a, b);    };  };}function sum(a, b) {  return a + b;}let currieSum = curry(sum)alert(curry(a)(b)) // a + b// 更为高级的封装，在不确定传入的方法的参数需要多少个的时候，抽象的方法function curry(func) {  function curried(...args) {    if (args.length &gt;= func.length) {    //  当传入的参数大于或等于，func方法需要的参数时，运行该方法      return func.apply(this, args);    } else {      return function pass(...args2) {   //  当传入的参数不够传入的func的参数时，再次调用curried方法        return curried.apply(this, args.concat(args2));      }    }  }}</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>首先我们学习了<code>订阅发布模式</code>，这个是redux的基础架构，通过<code>subscribe</code>订阅事件，<code>dispatch</code>进行触发。</li><li>然后我们学习了<code>函数式编程之Compose函数</code>,可以将多个嵌套调用的函数，给合成一个函数，为多个redux的多个中间件调用打下了基础</li><li>我们首先学习了redux的核心思想，flux思想<ul><li>视图产生动作消息，将动作传递给调度器。   </li><li>调度器将动作消息发送给每一个数据中心。    </li><li>数据中心再将数据传递给视图。</li></ul></li><li>我们手写完成了mini版本的redux，其代码仓库在github: <a href="https://github.com/tonghuitop/myRudex" target="_blank" rel="noopener">https://github.com/tonghuitop/myRudex</a></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p>官方文档：<a href="https://redux.js.org/" target="_blank" rel="noopener">https://redux.js.org/</a><br>GitHub源码：<a href="https://github.com/reduxjs/redux" target="_blank" rel="noopener">https://github.com/reduxjs/redux</a><br>手写一个Redux，深入理解其原理: <a href="https://segmentfault.com/a/1190000023084074" target="_blank" rel="noopener">https://segmentfault.com/a/1190000023084074</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> redux </tag>
            
            <tag> ts </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器-一个页面从输入URL到页面加载显示完成，这个过程都发生了什么？</title>
      <link href="/posts/9174025056.html"/>
      <url>/posts/9174025056.html</url>
      
        <content type="html"><![CDATA[<h3 id="基础知识依赖"><a href="#基础知识依赖" class="headerlink" title="基础知识依赖"></a>基础知识依赖</h3><h4 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h4><ul><li><p>五层因特尔协议栈:</p><ul><li>应用层(dns、http): DNS解析成IP并完成http请求发送</li><li>传输层(tcp，udp): 三次握手四次挥手模式建立tcp连接</li><li>网络层(IP、ARP)：IP寻址</li><li>数据链路层(ppp): 将请求数据封装成帧</li><li>物理层: 利用物理介质传输比特流(传输的时候通过双绞线，电磁波等)</li></ul></li><li><p>OIS七层框架: [多了两层，会话层，表示层]</p><ul><li>表示层: 管理不同用户和进程之间的对话</li><li>会话层：处理两个通信系统重交换信息的方式</li></ul></li><li><p>get和post的区别:</p><ul><li>get产生一个tcp数据包 </li><li>get请求时会把headers和data数据一起发送出去</li><li>post请求时，浏览器先发送headers，服务器100继续，浏览器再发送data。</li></ul></li><li><p>DNS查询得到IP</p><ol><li>请求信息：首先查看域名的本地DNS缓存，该缓存存储计算机最近检索到的信息，如果计算机不知道答案，那么就需要执行一个DNS查询来查找答案</li><li>询问递归式DNS服务器<ul><li>如果信息不存储在本地，计算机会联系您的ISP（网络提供商）的递归DNS服务器</li><li>这些专用计算机会为你执行一个DNS查询工作</li><li>递归服务器有自己的缓存，所以这个查询过程通常在这里完成，并将信息还回给用户</li></ul></li><li>询问根域名服务器<ul><li>如果递归服务器没有答案，它们会查询根域名服务器</li><li>根域名服务器是一种计算机，它扮演着一种DNS的电话接线员的角色，他们不知道答案，但可以将我们的疑问指向知道在那里可以找到答案的人。</li></ul></li><li>询问TLD域名服务器<ul><li>根域名服务器将查到请求的第一部分，按从右到左的顺序，从<a href="http://www.tonghuiwu.top中找到.top，并将请求指向.top对应的顶级域名服务器(TLD).top" target="_blank" rel="noopener">www.tonghuiwu.top中找到.top，并将请求指向.top对应的顶级域名服务器(TLD).top</a></li><li>每个TLD，如果（.com, .org, .us, .top）都有自己的顶级域名服务器</li><li>这些服务器没有我们需要的信息，但他们可以直接将我们引导到有信息的服务器。</li></ul></li><li>询问权威的DNS服务器<ul><li>TLD域名服务器会继续检查请求的下一部分（tonghuiwu）<a href="http://www.tonghuiwu.com，并将查询指向负责此特定域名的服务器" target="_blank" rel="noopener">www.tonghuiwu.com，并将查询指向负责此特定域名的服务器</a></li><li>这些权威的服务器将负责了解关于特定域的所有信息，并将信息存储在DNS记录。</li></ul></li><li>找回记录<ul><li>递归服务器从权威服务器中检索tonghuiwu.top的记录，并将记录存储在本地缓存<ul><li>如果其他任何人请求tonghuiwu.top的主机记录，递归服务器已经有答案，不需要再次进行查找</li><li>素有记录都有一个期限，一个段时间后，递归服务器将需要要求一个新的记录副本，以确保信息不会过时。</li></ul></li></ul></li><li>接受答案<ul><li>有了答案，递归服务器将记录返回到计算机</li><li>然后浏览器就可以根据IP地址和服务器进行连接建立</li></ul></li></ol></li><li><p>TCP/IP请求</p><ul><li>http的本质就是TCP/IP请求</li><li>需要经历3次握手建立连接，4次挥手断开连接</li><li>TCP将http长报文划分为短报文，通过三次握手与服务器建立连接，进行可靠传输</li><li><strong>三次挥手：</strong><ul><li>客户端：你是***服务器么？</li><li>服务器：我是***服务器，你是客户端吗？</li><li>客户端： 是的，我是客户端</li><li>建立连接成功后，接下来就可以进行正式的传输数据</li></ul></li><li><strong>四次挥手断开连接</strong><ul><li>主动方： 我的数据已经发送完了，将要关闭了向你那边的信息发送通道【发送FIN报文段，进入FIN_WAIT_1状态】</li><li>被动方： 收到通道关闭的信息，发送我同意你的关闭请求【收到FIN报文，发送ACK报文段】</li><li>被动方： 我现在也关闭了向你那边发送的信息的通道，请求关闭【发送FIN报文段，被动方进入LAST_ACK状态】</li><li>主动方： 收到了被动方的关闭请求，向主动方发送【ACK报文段】，然后进入TIME_WAIT状态,在一段时间内，没有收到被动方的信息后，也关闭连接</li><li>被动方： 收到主动方的ACK报文后，关闭连接</li></ul></li></ul></li><li><p>TCP/IP的并发限制：</p><ul><li>浏览器对同一个域名下并发的TCP连接时有限制的(2-10个不等)</li><li>在http1.0中，一个资源的下载就需要一个tcp/ip请求</li></ul></li></ul><h4 id="浏览器机制"><a href="#浏览器机制" class="headerlink" title="浏览器机制"></a>浏览器机制</h4><ol><li><p>进程和线程的概念</p><ul><li>进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位。<ul><li><strong>资源开销：</strong><ul><li><strong>进程：</strong> 每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销</li><li><strong>线程：</strong> 线程可以成轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器(PC)，线程之间的切换的开销小</li></ul></li><li><strong>包含关系</strong><ul><li><strong>进程：</strong> 如果一个进程内有多个线程，执行过过程不是一条线的，而是多条线（线程）共同完成的</li><li><strong>线程：</strong> 线程是进程的一部分，所以线程也被称为清权进程或者轻量级进程。</li></ul></li><li><strong>内存分配</strong><ul><li><strong>进程：</strong> 进程之间的地址空间和资源是相互独立的</li><li><strong>线程：</strong> 同一个进程的线程共享本进程的地址空间和资源</li></ul></li><li><strong>影响关系</strong><ul><li><strong>进程：</strong> 一个进程崩溃后，在保护模式下不会对其他进程产生影响。</li><li><strong>线程：</strong> 一个线程崩溃后，整个进程都会死掉。</li><li><strong>注:</strong> 多进程比多线程健壮</li></ul></li><li><strong>执行过程</strong><ul><li><strong>进程：</strong> 每个独立的进程有程序运行的入口、顺序执行序列和程序出口。</li><li><strong>线程：</strong> 线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行.</li></ul></li></ul></li></ul></li><li><p>多进程的浏览器</p><blockquote><p>浏览器是多进程的，有一个主控进程，以及每一个tab页面都会开一个进程(某些情况下多个tab由于优化策略会合并)      </p></blockquote><p><strong>浏览器主要进程</strong></p><ol><li><strong>Browser进程：浏览器的主进程，负责协调、主控，只有一个</strong><ul><li>负责浏览器界面的显示、与用户交互（如前进、后退等）</li><li>负责各个页面的管理，创建和销毁其他进程</li><li>将Renderer进程得到的内存中的Bitmap绘制到用户界面上</li><li>网络资源的管理和下载等</li></ul></li><li><strong>第三*方插件进程</strong><ul><li>每种类型的插件对应一个进程，仅当该插件使用时才创建</li></ul></li><li><strong>GPU进程</strong><ul><li>最多一个，用于3D绘制等</li></ul></li><li><strong>浏览器渲染进程（Renderer进程、浏览器内核、内部是多线程）</strong><ul><li>默认每打开一个tab页面，就会启动一个Renderer进程</li><li>负责页面的渲染，脚本的执行，事件的处理。</li></ul></li></ol><p><strong>浏览器多进程的优势</strong></p><ol><li>避免单个page crash影响整个浏览器</li><li>避免第三方插件crash影响整个浏览器</li><li>多进程充分利用多核优势</li><li>方便使用沙盒模型隔离插件等进程，提高浏览器稳定性</li></ol><p><strong>浏览器内核（渲染进程）</strong></p><ol><li><strong>GUI渲染进程</strong><ul><li>负责浏览器界面的渲染，接卸HTML、CSS，构建DOM树和RenderObject树，布局和绘制等</li><li>当界面需要重绘制（Repaint）或由于某种操作引发回流（reflow）时该线程会执行</li><li><strong>注意：GUI渲染线程和JS引擎线程是互斥的，</strong>当JS引擎执行时GUI线程会被挂起，GUI更新会保存在一个队列中等JS引擎空闲时，立即执行。</li></ul></li><li><strong>JS引擎线程</strong><ul><li>JS内核，负责处理JavaScript脚本程序（V8引擎）</li><li>负责解析JavaScript脚本，运行代码</li><li>JS引擎一直等待着任务队列中的任务到来，然后加以处理，一个tab页面（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序</li><li><strong>注意：由于GUI渲染线程和JS引擎线程是互斥的，</strong>所以如果JS程序运行时间过长，这样会导致页面渲染不连贯，导致页面渲染加载阻塞。</li></ul></li><li><strong>事件触发线程</strong><ul><li>归属于浏览器，而不是JS引擎，用来控制事件循环</li><li>当JS引擎执行代码块如setTimeOut时（也可以来自浏览器内核的其他线程，如鼠标单击事件、AJAX异步请求等），会将对应的任务添加到事件线程中</li><li>对应的事件符合触发条件被触发时，该线程就会把使劲按添加到JS的待处理队列的队尾，等待JS引擎的处理</li><li><strong>注意：由于JS的单线程的关系</strong>所以这些待处理队列中的事件都是排队等待JS引擎处理（当JS引擎空闲时才会去执行）。</li></ul></li><li><strong>定时触发器线程</strong><ul><li>setTimeOut与setInterval所在的线程</li><li>浏览器的定时计数器并不是由JavaScript引擎计数的，（因为JavaScript是单线程，如果处于阻塞状态就会影响计时准确）因此通过单独的线程来计时并触发定时（<strong>注：计时完毕后，添加到事件队列，等待JS引擎空闲时执行，并不是立即执行</strong>）</li></ul></li><li><strong>异步http请求线程</strong><ul><li>在XMLHttpRequest在连接后是通过浏览器新开一个线程请求的</li><li>将检测到状态变更时，如果设置有回调函数，异步线程就将产生状态变更事件，将这个回调再放到事件队列中，再由JS引擎执行。</li></ul></li></ol></li></ol><h3 id="一个页面从输入URL到加载显示完成，这个过程发生了什么？"><a href="#一个页面从输入URL到加载显示完成，这个过程发生了什么？" class="headerlink" title="一个页面从输入URL到加载显示完成，这个过程发生了什么？"></a>一个页面从输入URL到加载显示完成，这个过程发生了什么？</h3><ol><li>首先浏览器开启一个线程来处理这个请求</li><li>用户输入过程中，浏览器进行下拉联想，根据历史记录补全url，或者添加http协议头</li><li>判断强缓存：是否存在未过期的缓存，如果存在直接渲染页面，否则发起网络请求。</li><li>网络请求阶段：<ol><li>浏览器会对URL进行解析，一般包括（协议头、主机域名或IP地址、端口号、请求路径、查询参数、hash等），然后开启网络线程发出一个完整到http请求</li><li>当然一般我们输入的URL是服务器域名，这时就需要DNS通过域名查询得到对应的IP</li><li>DNS首先会查看浏览器DNS缓存，没有就查询计算机本地DNS缓存，还没有就询问递归式DNS服务器（即网络提供商，一般这个服务器都会有自己的缓存，所以IP查询一般在这里完成），如果没有缓存，那就需要通过根域名和TLD域名服务器指到对应的权威DNS服务器找回记录，并缓存到递归式服务器，然后递归服务器在将记录返回给本地。</li><li>有了IP地址，此时网络层便会通过IP地址寻的对应服务器的物理地址</li><li>寻得服务器地址，客户端在网络传输层便可以和服务器通过三次握手建立tcpip连接</li><li>连接建立后网络数据链路层将数据包装成帧；</li><li>最后物理层利用物理介质进行传输；</li><li>到了服务器，就会通过相反的方式将数据一层一层的还原回去；</li><li>请求到了后台服务器，一般会有统一的验证，如安全验证、跨域验证等，验证未通过就直接返回相应的http报文</li><li>验证通过后，就会进入后台代码，此时程序收到请求，然后执行对应的操作（如查询数据库等）；</li><li>如果浏览器访问过，且缓存上有对应的资源，便会与服务器最后修改时间对比，一致便返回304，告诉浏览器可使用本地缓存；【协商缓存】</li><li>前端浏览器接收到响应成功的报文后便开始下载网页</li></ol></li><li>获取的到网页将被交给浏览器内核（渲染进程）进程处理<ol><li>根据顶部定义的DTD类型进行对应的解析方式</li><li>渲染进程内部是多线程的，网页的解析将会被交给内部的GUI渲染线程处理</li><li>首先渲染线程中的HTML解析器，将HTML网页和资源从字节流解释转换成字符流</li><li>通过词法分析器将字符流解释成词语</li><li>之后经过语法分析器根据词语构成节点，最后通过这些节点组建一个DOM树</li><li>这个过程中，如果遇到DOM节点时JavaScript代码，就会调用JavaScript引擎对JavaScript代码进行解释执行，此时由JavaScript引擎和GUI渲染线程互斥，GUI渲染线程就会被挂起，渲染过程停止；如果JavaScript代码的运行中对DOM树进行了修改，那么DOM的构建需要从新开始</li><li>如果节点需要依赖其他资源，如（图片，CSS等），便会调用网络模块的资源加载器来加载它们，但它们是异步的，不会阻塞当前DOM树的构建。style正常情况下，css不会阻塞DOM树渲染，除非有通过@import动态导入的样式才会阻塞。img: 不会阻塞DOM渲染，但是如果没有设置宽高，加载完成后会触发DOM回流</li><li>如果遇到的是JavaScript资源URL（没有标记异步），则需要停止当前DOM的构建，直到JavaScript的资源加载并被JavaScript引擎执行后才继续构建DOM。<strong>async属性：</strong>脚本加载不阻碍DOM的构建，脚本加载完成后，阻碍DOM的构建，立即调用JS引擎执行脚本。<strong>defer属性：*</strong>脚本加载不阻碍DOM的构建，脚本的执行要在所有元素解析完成之后，DOMContentLoaded事件触发之前完成。</li><li>对于CSS，CSS解释器会将CSS文件解释生成内部表示结构，生成CSS规则树</li><li>然后合并CSS规则树和DOM树，生成render渲染树。根据渲染树，计算它们在设备视口内的确切位置和大小，生成layout Tree。</li><li>最后对render树进程布局和绘制，并将结果通过IO线程传递给Browser控制进程进行显示。</li></ol></li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 浏览器 </tag>
            
            <tag> FE </tag>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础之六大继承</title>
      <link href="/posts/917402502.html"/>
      <url>/posts/917402502.html</url>
      
        <content type="html"><![CDATA[<p>引言：</p><blockquote><p>大多数OO(Object Oriented)语言都支持两种继承方式：接口继承和实现继承，而ECMAScript中无法实现接口继承，ECMAScript支持实现继承，而且其实现继承方式主要是依靠原型链来实现，本文给大家介绍js实现继承的六种方式。</p></blockquote><h3 id="方式一：原型链继承"><a href="#方式一：原型链继承" class="headerlink" title="方式一：原型链继承"></a>方式一：原型链继承</h3><p><strong>核心：</strong> 子类型的原型为父类型的一个实例对象。</p><pre><code>function SuperType() {  this.property = true;}SuperType.prototype.getSuperValue = function() {  return this.property;}function SubType() {  this.subproperty = false;}// 继承SubType.prototype = new SuperType()SubType.prototype.getSubValue = function () {  return this.subproperty}let instance = new SubType()</code></pre><blockquote><p>子类的实例<code>instance</code>可以通过<code>__proto__</code>访问到<code>SubType.prototype</code>也就是<code>SuperType</code>的实例。这样就可以访问到父类的私有方法，然后再通过<code>__proto__</code>指向父类的<code>prototype</code>就可以获得父类原型上的方法。 </p></blockquote><p><strong>特点：</strong></p><ul><li>父类新增的原型方法/原型属性，子类都可以访问到</li><li>简单，易于实现</li></ul><p><strong>缺点：</strong></p><ul><li>无法实现多继承</li><li>来自原型对象的所有属性被所有实例共享</li><li>创建子类实例时，无法向父类构造函数传参</li><li>为子类新增属性和方法，必须要在<code>SubType.prototype = new SuperType()</code>之后执行，不能放到构造器中。</li></ul><h3 id="方式二：借用构造函数继承"><a href="#方式二：借用构造函数继承" class="headerlink" title="方式二：借用构造函数继承"></a>方式二：借用构造函数继承</h3><p><strong>核心：</strong> 在子类型构造函数中通用<code>call()</code>调用父类型构造函数</p><pre><code>function Person(name, age) {  this.name = name,  this.age = age  this.setName = function () {}}Person.prototype.setAge = function() {}function Student(name, age, price) {  Person.call(this, name, age)  this.price = price}const Tom = new Student('Tom', 20, 3000)</code></pre><p><strong>特点：</strong></p><ul><li>解决了原型链继承中子类实例共享父类引用属性的问题</li><li>创建子类实例时，可以向父类传递参数</li><li>可以实现多继承(call多个父类对象)</li></ul><p><strong>缺点：</strong></p><ul><li>实例并不是父类的实例，只是子类的实例，实例的原型链上没有Person.prototype对象</li><li>只能继承父类的实例属性和方法，不能继承原型属性和方法</li><li>无法实现函数复用，每个子类都有父类实例函数的副本，影响性能。</li></ul><h3 id="方法三：原型链-借用构造函数的组合继承"><a href="#方法三：原型链-借用构造函数的组合继承" class="headerlink" title="方法三：原型链+借用构造函数的组合继承"></a>方法三：原型链+借用构造函数的组合继承</h3><p><strong>核心：</strong>通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用。</p><pre><code>function Person(name, age) {  this.name = name,  this.age = age  this.setName = function () {    console.log(this.name)  }}Person.prototype.setAge = function() {}function Student(name, age, price) {  Person.call(this, name, age)  this.price = price  this.setScore = function() {}}Student.prototype = new Person()// 组合继承也是需要修复构造函数指向Student.prototype.constructor = StudentStudent.prototype.sayHello = function () {  console.log(this.age)}const Tom = new Student('Tom', 20, 3000)</code></pre><p><strong>特点：</strong></p><ul><li>可以继承实例属性/方法，也可以继承原型属性/方法</li><li>不存在引用属性共享问题</li><li>函数可复用</li></ul><p><strong>缺点：</strong></p><ul><li>调用了两次父类构造函数，生成了两份实例.<blockquote><p>第一次时在创建子类型原型的时候，第二次是在子类型构造函数的内部，子类型最终会包含父类型对像的全部实例属性，但我们不得不在调用子类型构造函数时重写这些属性。</p></blockquote></li></ul><h3 id="方法四：组合继承优化1"><a href="#方法四：组合继承优化1" class="headerlink" title="方法四：组合继承优化1"></a>方法四：组合继承优化1</h3><p><strong>核心：</strong>通过父类原型和子类原型指向同一个对象，子类可以继承父类的公有方法当作自己的公有方法，而且不会初始化两次实例方法/属性。</p><pre><code>function Person(name, age) {  this.name = name,  this.age = age  this.setName = function () {    console.log(this.name)  }}Person.prototype.setAge = function() {}function Student(name, age, price) {  Person.call(this, name, age)  this.price = price  this.setScore = function() {}}Student.prototype = Person.prototypeStudent.prototype.sayHello = function () {}const Tom = new Student('Tom', 20, 3000)</code></pre><p>但这种方法不能辨别对象是子类还是父类实例化</p><pre><code>Tom instanceof Student // trueTom instanceof Person  // trueTom.constructor        // Person</code></pre><p><strong>特点：</strong></p><ul><li>不会初始化两次实例方法/属性，避免组合继承的缺点</li></ul><p><strong>缺点：</strong></p><ul><li>没办法辨别是实例是子类还是父类创造的，子类和父类的构造函数指向是同一个</li></ul><h3 id="方式五：组合继承优化2"><a href="#方式五：组合继承优化2" class="headerlink" title="方式五：组合继承优化2"></a>方式五：组合继承优化2</h3><p><strong>核心：</strong>借助原型可以基于已有的对象来创造对象，<code>var B = Object.create(A)</code>已A为原型，生成了B对象。B继承了A的所有属性和方法。</p><pre><code>function Person(name, age) {  this.name = name,  this.age = age  this.setName = function () {    console.log(this.name)  }}Person.prototype.setAge = function() {}function Student(name, age, price) {  Person.call(this, name, age)  this.price = price  this.setScore = function() {}// 核心代码Student.prototype = Object.create(Person.prototype)Student.prototype.constructor = Studentconst Tom = new Student('Tom', 20, 3000)</code></pre><p>Student继承了所有的Person原型对象的属性和方法，目前来说是最完美的继承方法.</p><h3 id="ES6中class的继承"><a href="#ES6中class的继承" class="headerlink" title="ES6中class的继承"></a>ES6中class的继承</h3><blockquote><p>ES5的继承，实质是先创建子类的实例对象this，然后再将父类的方法添加到this上面。ES6的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面(调用super方法)，然后再用子类的构造函数修改this。</p></blockquote><pre><code>class Person {  constructor(name, age) {    this.name = name    this.age = age  }  setName() {    console.log(this.name)  }}class Student extends Person {  constructor(name, age, price) {    super(name, age)    this.price = price  }  setScore() {  }}const Tom = new Student('tom', 20, 3000)</code></pre><p><strong>优点：</strong></p><ul><li>语法简单，代码干净整洁</li></ul><p><strong>缺点：</strong></p><ul><li>并不是所有的浏览器都支持class关键字</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 原型链 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础之原型链</title>
      <link href="/posts/917402501.html"/>
      <url>/posts/917402501.html</url>
      
        <content type="html"><![CDATA[<h3 id="什么是原型链"><a href="#什么是原型链" class="headerlink" title="什么是原型链"></a>什么是原型链</h3><blockquote><p>ECMA-262把<strong>原型链</strong>定义为ECMAScript的主要继承方式。其思想是通过原型链继承多个引用类型的属性和方法。构造函数、原型和实例的关系如下：<br>每个构造函数都是一个原型对象，原型有一个属性<code>constructor</code>指回构造函数，而实例有一个内部指针<code>__proto__</code>指向原型。如果原型是另一个类型的的实例。那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。即够成了原型链</p></blockquote><pre><code>function SuperType() {  this.property = true;}SuperType.prototype.getSuperValue = function() {  return this.property;}function SubType() {  this.subproperty = false;}// 继承SubType.prototype = new SuperType()SubType.prototype.getSubValue = function () {  return this.subproperty}let instance = new SubType()</code></pre><p>即<img src="/img/blog/prototype.jpg" alt="prototype"><br>注意：</p><blockquote><p><strong>proto</strong>属性在ES6时代才被标准化，以确保Web浏览器的兼容性，但是不推荐使用，除了标准化的原因之外还有性能问题。通过改变一个对象的[[Prototype]]属性来改变和继承属性会对性能造成非常严重的影响，并且性能消耗的时间也不是简单的花费在obj.<strong>proto</strong> = …语句上，它还会影响到所有继承自该[[Prototype]]的对象。推荐使用Object.getPrototypeOf()。<br>如果要读取或修改对象的[[Prototype]]属性，建议使用如下方案，但是此时设置对象的[[Prototype]]依旧是一个缓慢的操作，如果是性能问题，就要避免这种操作</p></blockquote><pre><code>// 获取Object.getPrototypeOf()// 修改Object.setPrototypeOf()</code></pre><h4 id="手动实现instanceof"><a href="#手动实现instanceof" class="headerlink" title="手动实现instanceof"></a>手动实现instanceof</h4><p><code>instanceof</code>操作符用于检测构造函数的<code>prototype</code>属性是否出现在某个实例对象的原型链上。</p><pre><code>instance instanceof SubType // trueinstance instanceof SuperType // trueinstance instanceof Object  // true</code></pre><p>instanceof原理就是一层一层查找<strong>proto</strong>,如果和constructor.prototype相等则返回true，如果一直没有查找成功，则返回false。</p><pre><code>// tonghuifunction instanceOf(instance, constructor) {  // 获取构造函数的原型对象  const constructorPrototype = constructor.prototype  let instanceProto = Object.getPrototypeOf(instance)  while(true) {    if(instanceProto === null) {      return false    }    if(instanceProto === constructorPrototype) {      return true    }    instanceProto = Object.getPrototypeOf(instanceProto)  }}</code></pre><h4 id="手动模拟实现new"><a href="#手动模拟实现new" class="headerlink" title="手动模拟实现new"></a>手动模拟实现new</h4><blockquote><p>new运算符创建一个用户定义对象类型的实例或具有构造函数的内置对象的实例。—（来自MDN）</p></blockquote><pre><code>let instance = new SubType()instance.subproperty  // falseinstance.getSubValue()  // falseinstance.getSuperValue() // true</code></pre><p>可以看出<code>new</code>创建的实例有以下2个特性</p><ul><li>可以访问到构造函数里的属性</li><li>可以访问原型链里的属性</li></ul><p>即当new SubType(…)会发生下面3件事情</p><ul><li>1.一个继承SubType.prototype的新对象被创建— 需要使用setPrototypeOf</li><li>2.使用指定的参数调用构造函数<code>SubType</code>，并且将this绑定到新创建的对象。<code>new SubType</code>等同于<code>new SubType()</code>,也就是没有指定参数列表，<code>SubType</code> 不带任何参数调用的情况。—需要使用arguments</li><li>3.由构造函数返回的对象是<code>new</code>表达式的结果。如果构造函数没有显示返回一个对象，则使用步骤1创建的对象。<pre><code>function new() {// 创建一个空对象const obj = new Object()// 获取构造函数const Constructor = [].shift.call(arguments)// 绑定this实现Object.setPrototypeOf(obj, Constructor.prototype)const rest = Con.apply(obj, arguments)// 如果return rest instanceof Object ? rest: obj;}</code></pre><h3 id="终极问题—Object和Function，鸡生蛋，蛋生鸡问题。"><a href="#终极问题—Object和Function，鸡生蛋，蛋生鸡问题。" class="headerlink" title="终极问题—Object和Function，鸡生蛋，蛋生鸡问题。"></a>终极问题—Object和Function，鸡生蛋，蛋生鸡问题。</h3><pre><code>Object instanceof Function   // trueFunction instanceof Object   // true</code></pre>我们知道，原型链的顶端是<code>Object.prototype</code>，所有对象都继承于它。<code>Object.prototype.constructor</code>是Object，所以，Function对象的原型链上一定会有Object构造函数。问题在于<code>Object instanceOf Function</code>，我们再看一种情况。   <pre><code>Function.prototype.constructor === Function  // trueFunction.__proto__ === Function.prototype    // true</code></pre>问题在于Function.<strong>proto</strong>[对象的<strong>proto</strong>属性:指向原型]]和Functin.prototype[函数的prototype属性，指向原型。]是同一个对象。往下看<pre><code>Object.__proto__ === Function.prototypeArray.__proto__ === Function.prototypeSuperType.__proto__ === Function.prototype</code></pre><img src="/img/blog/javascript-prototype.jpg" alt="javascript prototype"><br>所以所有的的函数的原型是Function.prototype对象，回归规范<blockquote><ol><li>Function.prototype是个不同于一般函数(对象)的函数(对象)   <ul><li>Function.prototype像普通函数一样可以调用，但总是返回undefined   </li><li>普通函数实际上是Function的实例，即普通函数继承于Function.prototype。func.<strong>proto</strong> === Function.prototype</li><li>Function.prototype继承于Object.prototype，并且没有prototype属性。func.prototype是普通对象，Function.prototype.prototype是null</li><li>所以，Function.prototype是个另类的函数，先于Function产生的。</li></ul></li></ol></blockquote><pre><code>Function.prototype instanceof Functin  // falseObject.prototype instanceof Object     // false</code></pre>综上所述：现有Object.prototype[原型链最顶端],Functin.prototype继承Object.prototype而产生，最后，Function和Object和其它构造函数继承于Function.prototype而产生。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 原型链 </tag>
            
            <tag> instanceof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过hexo+travis+cloundflare[CDN]打造个人站点</title>
      <link href="/posts/3274106048.html"/>
      <url>/posts/3274106048.html</url>
      
        <content type="html"><![CDATA[<h3 id="本博客目标"><a href="#本博客目标" class="headerlink" title="本博客目标"></a>本博客目标</h3><blockquote><p>通过hexo在github page搭建博客<br>通过travis完成CI发布<br>通过cloundflare进行CDN，加速网站访问速度<br>添加google收录,添加百度站长收录  </p></blockquote><h4 id="使用hexo生成网站"><a href="#使用hexo生成网站" class="headerlink" title="使用hexo生成网站"></a>使用hexo生成网站</h4><p>Hexo是一款基于Node.js的静态博客框架，可以方便的生成静态网页托管在Github和coding上。</p><ul><li>安装git，网站有众多git教程，不是本博重点，请自行查找。   </li><li>安装node，tonghui使用的<code>14.0.0</code>    <blockquote><p>特别提醒：如果使用了nvm来管理node版本，如果在安装nvm前，已安装过node，请删除干净下方文件【tonghui在此踩了深深的坑】<br>C:\Program Files (x86)\Nodejs<br>C:\Program Files\Nodejs<br>C:\Users{User}\AppData\Roaming\npm（或%appdata%\npm）<br>C:\Users{User}\AppData\Roaming\npm-cache（或%appdata%\npm-cache）   </p></blockquote></li><li>安装hexo<blockquote><p>npm install -g hexo-cli</p></blockquote></li><li>创建自己的blog项目<blockquote><p>hexo init myblog<br>cd myblog<br>npm install</p></blockquote></li><li>hexo的目录<blockquote><p>node_modules: 依赖包<br>public: 存放生成的页面<br>scaffolds：生成文章的一些模板<br>source: 用来存放你的文章<br>themes: 主题<br>_config.yml： 博客的配置文件  </p></blockquote></li><li>hexo的命令<pre><code>hexo clean // 清楚生成的静态HTMLhexo generate // 生成静态HTMLhexo server  // 开启本地hexo服务，进行预览hexo deploy // hexo部署</code></pre>tonghui习惯了自己的命令，在package.json的stript中进行了更改<pre><code>"clean": "hexo clean","build": "hexo generate","dev": "hexo server","deploy": "hexo clean &amp;&amp; hexo generate &amp;&amp; gulp &amp;&amp; hexo deploy"</code></pre></li><li>本地开启hexo服务<pre><code>npm run dev</code></pre><img src="/img/blog/hexo-blog.jpg" alt="hexo-blog"></li></ul><h5 id="hexo项目与github关联"><a href="#hexo项目与github关联" class="headerlink" title="hexo项目与github关联"></a>hexo项目与github关联</h5><ul><li><p>首先在github上新建一个仓库，仓库名称为[githubName].github.io</p><blockquote><p>例如博主github账号为tonghuitop，所以该仓库明名为tonghuitop.github.io</p></blockquote></li><li><p>配置hexo项目的github仓库。</p><blockquote><p>项目中文件夹下有<code>_config.yml</code>文件，其中在文件的deploy属性中，配置远程仓库，</p></blockquote><p>```<br>deploy:</p></li><li><p>type: git<br>repo:<br>  coding: <a href="mailto:git@github.com">git@github.com</a>:tonghuitop/tonghuitop.github.io.git<br>branch: master</p><pre><code>至此，github与hexo项目关联已于，执行`npm run deploy`,将在github仓库中，看到hexo生成的静态文件。，此时访问githubName.github.io即可访问你的站点。### 通过travis CI进行源码仓库分离，以及自动发布。&gt; 当前项目只有一个仓库即`tonghuitop.github.io`，master分支放置的是编译过的静态html文件，所以源码如果也放置在该仓库中，需要另起一个分支，但github免费用户不支持，私有项目发布githu page。如果都是源码公开，那么在项目中后续配置的密钥都将会公开，这是不能接受的。所以建立如下工作流程。![travis ci flow](/img/blog/ci-flow.jpg)travis与github是集成的，所以在原有的项目中添加.travis.yml文件即可。</code></pre><p>cache:<br>directories:</p><ul><li>node_modules</li></ul><p>before_install:</p><ul><li>npm install -g hexo-cli</li></ul><p>install:</p><ul><li>npm install</li><li>npm install hexo-deployer-git –save</li></ul><h1 id="执行清缓存，生成网页操作"><a href="#执行清缓存，生成网页操作" class="headerlink" title="执行清缓存，生成网页操作"></a>执行清缓存，生成网页操作</h1><p>script:</p><ul><li>yarn clean</li></ul><h1 id="设置git提交名，邮箱；替换真实token到-config-yml文件，最后depoy部署"><a href="#设置git提交名，邮箱；替换真实token到-config-yml文件，最后depoy部署" class="headerlink" title="设置git提交名，邮箱；替换真实token到_config.yml文件，最后depoy部署"></a>设置git提交名，邮箱；替换真实token到_config.yml文件，最后depoy部署</h1><p>after_script:</p></li><li><p>git config user.name “***”</p></li><li><p>git config user.email “****@outlook.com”</p><h1 id="替换同目录下的-config-yml文件中gh-token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！"><a href="#替换同目录下的-config-yml文件中gh-token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！" class="headerlink" title="替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！"></a>替换同目录下的_config.yml文件中gh_token字符串为travis后台刚才配置的变量，注意此处sed命令用了双引号。单引号无效！</h1></li><li><p>sed -i “s/gh_token/${GH_TOKEN}/g” ./_config.yml</p></li><li><p>yarn deploy<br>```</p></li></ul><p>  <strong>注意：</strong></p><blockquote><p>在ci中执行git push操作，使用的是<code>https://gh_token@github.com/tonghuitop/tonghuitop.github.io.git</code>api，此时的gh_push是在gihub平台获取的私人token，是为了访问通过api来访问自己的仓库</p></blockquote><h3 id="通过cloundflare为自己的网站添加CDN"><a href="#通过cloundflare为自己的网站添加CDN" class="headerlink" title="通过cloundflare为自己的网站添加CDN"></a>通过cloundflare为自己的网站添加CDN</h3><p>  个人使用cloundflare的免费版就可以了，而且cloundflare在国内也有合作，所以也提供服务。</p><h5 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h5><p>  至此本网站的整个搭建流程已完成。<br>    - 网站主题是matery<br>    - 网站的留言服务： valine。   </p><blockquote><p>不建议使用gitalk，因为它需要使用gitbu token，密钥目前在请求中是公开。`<br>    - googleAnalytics baiduAnalytics都已开启</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> travis </tag>
            
            <tag> cloudflare </tag>
            
            <tag> CDN </tag>
            
            <tag> CI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手写简易版react】之MyReact库的diff算法</title>
      <link href="/posts/3274106045.html"/>
      <url>/posts/3274106045.html</url>
      
        <content type="html"><![CDATA[<h6 id="前提回顾及本章期望"><a href="#前提回顾及本章期望" class="headerlink" title="前提回顾及本章期望"></a>前提回顾及本章期望</h6><blockquote><p>前面我们实现了React的基本功能，但是在子组件中触发父组件传给子组件的方法时，父组件进行了刷新，导致子组件被初始化了。原因是DOM的更新是全局更新的(已组件的方式去更新的。App里的数据发生改变，会去渲染所有的组件，DOM的频繁操作开销是很大的，可以精细化操作，比如修改了name数据，对应的DOM只去修改对应DOM。</p></blockquote><h4 id="首先我们来回顾一下首次挂载的流程"><a href="#首先我们来回顾一下首次挂载的流程" class="headerlink" title="首先我们来回顾一下首次挂载的流程"></a>首先我们来回顾一下首次挂载的流程</h4><p><img src="/img/react/react-mount-flow.jpg" alt="react的首次挂载流程图"></p><blockquote><p>首次挂载时，首先render根组件，通过createDomFromVnode方法将根组件进行DOM化，createDomFromVnode通过下策略进行work</p><ul><li>如果是文本类型(string/number)通过document.createTextNode方法实例化DOM</li><li>如果是document.element,通过document.createElement(vnode.tag)进行实例化DOM</li><li>如果vnode.tag是个方法，意味着vnode是MyReact组件<ul><li>此时抽象createComponent方法，因为vnode.tag是组件的构造函数，可以通过new来实例化组件[此时的实例化对象，仅是js对象]</li><li>由createComponent得到组件对象，接下需要js对象转化为DOM对象[抽象为renderComponent方法]，通过调用组件对象的render方法，得到组件的vnode，然后通过调用createDomFromVnode方法，得到组件的DOM树</li></ul></li></ul></blockquote><h4 id="什么是Diff算法"><a href="#什么是Diff算法" class="headerlink" title="什么是Diff算法"></a>什么是Diff算法</h4><blockquote><p>前面的文章中我们说过，React采用虚拟DOM技术实现对真实DOM的映射，即React Diff算法的差异查找实质是对两个JavaScript对象的差异查找：<br>基于三个策略：   </p><ul><li>Web UI中DOM节点跨层级的移动操作特别少，可以忽略不记。 (tree diff)</li><li>拥有相同类的两个组件将会生成相似的树形结构，拥有不同类的两个组件将会生成不同的树形结构(component diff)</li><li>对于同一层级的一组子节点，它们可以通过唯一id进行区分。(element diff)</li></ul></blockquote><h3 id="DIFF算法的具体实现"><a href="#DIFF算法的具体实现" class="headerlink" title="DIFF算法的具体实现"></a>DIFF算法的具体实现</h3><p><img src="/img/react/react-update-flow.jpg" alt="react-update-flow"></p><blockquote><p>分析：<br>当调用setState时，触发MyReactDom.renderComponent方法,然后调用diffNode方法对组件进行diff</p><ul><li>如果vnode是文本类型，判断内容是否更改，如果是，可直接更改</li><li>如果vnode是dom标签的更新，直接更新dom</li><li>如果是组件，更具组件的构造函数，判断是一类型组件<ul><li>如果是，更新组件的props属性，并生成vnode，与原组件进行diff</li><li>如果不是，生成新的组件，替换它</li></ul></li><li>diff元素属性</li><li>diffChildren 遍历字节点<ul><li>如果有key，则根据key查找对应的DOM与vnode，直接进行diff</li><li>没有key，只能通过遍历进行diff</li></ul></li></ul></blockquote><p><strong>代码具体实现：</strong></p><pre><code>/** * 渲染组件 * @param {MyReact.Component} component 组件对象 */function renderComponent(component, isMount = false) {  const vnode = component.render()  const dom = isMount ? createDomFromVnode(vnode) : diffNode(component.$root, vnode)  component.$root = dom  component.$root._component = component}/** * vnode的diff算法 * @param {HTMLElement} dom  * @param {VNode} vnode  * nodeType:  *   1 ---&gt; 元素节点 *   2 ---&gt; 属性节点 *   3 ---&gt; 文本节点 *   ... */function diffNode(dom, vnode) {  if(!vnode) {    return removeDom(dom)  }  let patchedDom = dom  // 如果是文本类型的虚拟DOM，要么替换内容，要么替换元素  if (['string', 'number'].includes(typeof vnode)) {    if (patchedDom.nodeType === 3 &amp;&amp; patchedDom.textContent !== vnode) {      patchedDom.textContent = vnode    }    return patchedDom  }  // 如果是组件，就调用diffComponent方法  if (typeof vnode === 'object' &amp;&amp; typeof vnode.tag === 'function') {    patchedDom = diffComponent(dom, vnode)    return patchedDom  }  // 如果存在但标签变了，就修正标签  if (dom.nodeName.toLowerCase() !== vnode.tag.toLowerCase()) {    patchedDom = document.createElement(vnode.tag)    setAttribute(patchedDom, vnode.attrs)    dom.childNodes.forEach((child) =&gt; patchedDom.appendChild(child))    replaceDom(patchedDom, dom)    return patchedDom  }  // diff attributes  diffAttributes(patchedDom, vnode)  // diff children  diffChildren(patchedDom, vnode.children)  return patchedDom}function diffComponent(dom, vnode) {  let { _component:component = {} } = dom || {}  if (component.constructor === vnode.tag) {    setComponentProps(component, vnode.attrs)  } else {    component = createComponent(vnode.tag, vnode.attrs)    setComponentProps(component, vnode.attrs, true)  }  return component.$root}function diffChildren(patchedDom, vChildren) {  const domChildren = patchedDom.childNodes  const domsHasKey = {}  for (let dom of domChildren) {    if (dom.key) {      domsHasKey[dom.key] = dom    }  }  // 用最长的做判断(dom, vdom)循环一次即可  let vChild  let patchChildDom  let length = Math.max(domChildren.length, vChildren.length)  for (let i = 0; i &lt; length; i++) {    vChild = vChildren[i]    if(!vChild) {      return removeDom(domChildren[i])    }    // 有key的处理逻辑    if (vChild.key &amp;&amp; domsHasKey[vChild.key]) {      patchChildDom = diffNode(domsHasKey[vChild.key], vChild)    } else {    // 不带key的处理逻辑      patchChildDom = diffNode(domChildren[i], vChild)    }    const { parentNode } = patchChildDom || {}    if (parentNode !== patchedDom) {      patchedDom.appendChild(patchChildDom)    }    setOrderInContainer(patchedDom, patchChildDom, i)  }}/** * 属性diff方法 * @param {HTMLElement} dom  * @param {VNode} vnode  */function diffAttributes(dom, vnode) {  const old = {}  const attrs = vnode.attrs  // 找到真实的dom的属性  for (var i = 0; i &lt; dom.attributes.length; i++) {   const attrs = dom.attributes[i]   old[attrs.name] = attrs.value  }  // 自己的属性不在新的属性里，把他删掉  for (let key in old) {    if(!(key in attrs)) {      setAttribute(dom, key, undefined)    }  }  // 重新遍历，设置为新的属性  for (let key in attrs) {    if(old[key] !== attrs[key]) {      setAttribute(dom, key, attrs[key])    }  }}/** * 给组件添加属性 * @param {Component} component  * @param {Object} props  */function setComponentProps(component, props, isMount=false) {  // 设置组件属性  component.props = props  // 渲染组件  renderComponent(component, isMount)}/** * 删除DOM * @param {HTMLElement} dcom  */function removeDom(dom) {  if(dom &amp;&amp; dom.parentNode) {    dom.parentNode.removeChild(dom)  }}/** * 替换DOM * @param {HTMLElement} newDom  * @param {HTMLElement} oldDom  */function replaceDom(newDom, oldDom) {  if(oldDom &amp;&amp; oldDom.parentNode) {    oldDom.parentNode.replaceChild(newDom, oldDom)  }}/** * 对DOM的排序 * @param {HTMLElement} container DOM容器 * @param {HTMLElement} dom  * @param {Number} order  */function setOrderInContainer(container, dom, order) {  // 如果本身位置是对应的，就不走下面的逻辑了  if(container.childNodes[order] !== dom) {    container.childNodes[order].insertAdjacentElement('beforebegin', dom)  }}</code></pre><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>本章完成了简易版本的diff算法，你学会了么。欢迎留言。下一章将完成MyReact的生命周期方法。<br>本项目源码：<a href="https://github.com/tonghuitop/myReact" target="_blank" rel="noopener">https://github.com/tonghuitop/myReact</a> 由于项目后期将会继续完善，本博客源码将在react-diff分支上。欢迎star。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> diff </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手写简易版react】之组件内数据的更新，以及父子组件的数据通信</title>
      <link href="/posts/3274106044.html"/>
      <url>/posts/3274106044.html</url>
      
        <content type="html"><![CDATA[<h6 id="前提回顾及本章期望"><a href="#前提回顾及本章期望" class="headerlink" title="前提回顾及本章期望"></a>前提回顾及本章期望</h6><blockquote><p>在<a href="https://tonghuiwu.top/posts/3274106043.html">上一章</a>中，我们从零开始完成了最基本的一个MyReact， 即vnode与真实dom的转换，以及MyReact的组件化。<br>页面数据的动态改变和react的核心diff算法，都将是本章的内容。</p></blockquote><h3 id="单个组件的页面更新"><a href="#单个组件的页面更新" class="headerlink" title="单个组件的页面更新"></a>单个组件的页面更新</h3><blockquote><p>MyReact是一个数据驱动的UI框架，所以一切UI的改变，本质是数据的更新<br>因为每个组件都有自己的state数据，同时还能更新自己的state，所以我们在MyReact.Component中实现该方法</p></blockquote><pre><code>class Component {  constructor(props) {    this.props= props    this.state = {}    renderComponent()  }  setState(state) {    Object.assign(this.state, state)  }}</code></pre><p>至此每个组件都有自己的state，并有自己的setState方法。<br><strong>思考：</strong>数据已经完成了更新。数据更新完成，UI如何更新呢。</p><blockquote><p>之前我们在MyReact.createComponent方法除了定义创建组件之外，还做了将组件渲染成真实的DOM，将渲染的逻辑抽离出来，当A组件进行更新时，调用渲染方法，重新渲染A组件</p></blockquote><pre><code>// myReactDom.js/** * 实例化组件方法 * @param {function} constructor: 组件的构造函数  * @param {object} attrs： 参数 */const createComponent = (constructor, attrs) =&gt; {  let component  if (constructor.prototype instanceof MyReact.Component) {    component = new constructor(attrs)  } else {    // 实例化组件,使得组件具有state, props    component = new MyReact.Component(attrs)    component.constructor = constructor    component.render = function() {      return this.constructor(attrs)    }  }  //调用组件的render方法，得到组件对应的vnode  const vnode = component.render()  // vnode转换成真实DOM  const dom = createDomfromVnode(vnode)  // 方便组件中拿到真实的DOM  component.$root = dom  return dom}/** * 渲染组件 * @param {*} component 组件对象 */const renderComponent = (component) =&gt; {  const vnode = component.render()  const dom = createDomfromVnode(vnode)  // 组件数据更新  if (component.$root &amp;&amp; component.$root.parentNode) {    component.$root.parentNode.replaceChild(dom, component.$root)  }  component.$root = dom  return dom}// myReact.jsclass Component {  constructor(props) {    this.props= props    this.state = {}  }  setState(state) {    Object.assign(this.state, state)    MyReactDom.renderComponent(this)  }}</code></pre><p><strong>案例：</strong> 小辉物理考了59，他努努力是否能够考到及格呢。</p><pre><code>// farctionimport MyReact from '../lib/myReact'class Fraction extends MyReact.Component {  constructor(props) {    super(props)    this.state = {      fraction: 59,    }  }  handleComeOn = () =&gt; {    const { fraction: olFraction } = this.state    this.setState({ fraction: olFraction + 1 })  }  render() {    const { fraction } = this.state    return (      &lt;div&gt;        &lt;h1&gt;小辉的物理考了{fraction}分&lt;/h1&gt;        &lt;button onClick={this.handleComeOn}&gt;加加油&lt;/button&gt;      &lt;/div&gt;    )   }}export default Fraction// index.jsimport Fraction from './faction'class App extends MyReact.Component {...  render() {    const { name, job, hobbys, hobbyIndex } = this.state    return (      &lt;div className="wrapper"&gt;        &lt;Fraction /&gt;    ...</code></pre><p><strong>结果：</strong> 小辉要一直努力的话，不仅能够及格，还能获得一朵小红花呢。</p><p><img src="/img/react/react-fraction.jpg" alt="小辉的小红花"></p><p><strong>思考：</strong> App组件中state中存储了team的总分，89分。在给小辉加油【点击button按钮】时，是否能够更新team的总分呢</p><h3 id="子组件与父组件的数据通信"><a href="#子组件与父组件的数据通信" class="headerlink" title="子组件与父组件的数据通信"></a>子组件与父组件的数据通信</h3><blockquote><p>小辉在给自己加油时，可以调用从团队借来的方法<code>onComeOn()</code>,给团队加油了.</p></blockquote><pre><code>// index.jsclass App extends MyReact.Component {  constructor(props) {    super(props)    this.state = {      teamPerformance: 89,    }// fraction.jshandleComeOn = () =&gt; {  const { onComeOn } = this.props  const { fraction: olFraction } = this.state  onComeOn()  this.setState({ fraction: olFraction + 1 })}</code></pre><p><strong>结果：</strong><br><img src="/img/react/team-performance.jpg" alt="小辉team的小红花"></p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><blockquote><p>通过抽离MyReactDom中的renderComponent–渲染组件的方法，在组件setState时，我们再调用该刚发，即可更新组件。<br>父子组件数据的通信，可以通过再子组件中调用父组件传给子组件的方法。   </p></blockquote><h4 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h4><blockquote><p>小辉在加油时，team【父组件】的分数更新了，自己的物理分【子组件】的分数没有更新。请大家思考，该问题将在下面文章，diff算法讲解。</p></blockquote><h5 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h5><blockquote><p>本篇完结，下篇将MyReact组件的数据更新，父子组件的通信。<br>本项目源码：<a href="https://github.com/tonghuitop/myReact" target="_blank" rel="noopener">myReact</a> 由于项目后期将会继续完善，本博客源码将在react-component-state分支上。欢迎star。</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> babel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【手写简易版react】之MyReact库的搭建及完成组件化</title>
      <link href="/posts/3274106043.html"/>
      <url>/posts/3274106043.html</url>
      
        <content type="html"><![CDATA[<h3 id="首先我们先了解一下React"><a href="#首先我们先了解一下React" class="headerlink" title="首先我们先了解一下React"></a>首先我们先了解一下React</h3><h4 id="react是什么"><a href="#react是什么" class="headerlink" title="react是什么"></a>react是什么</h4><blockquote><p>React是一个网页UI框架，通过组件化的方式解决视图层开发复用的问题，本质是一个组件化框架</p></blockquote><h4 id="React核心是什么"><a href="#React核心是什么" class="headerlink" title="React核心是什么"></a>React核心是什么</h4><blockquote><p>react的核心设计思路有三点，分别是声明式、组件化与通用性。<br><strong>声明式</strong>的优势在于直观与组合。<br><strong>组件化</strong>的优势在于试图的拆分与模块复用，可以更容易做到高内聚低耦合。<br><strong>通用性</strong>在于一次学习，随处编写。例如：React Native, React 360等，这里主要是靠虚拟DOM来保证实现。这使得React的使用范围变得足够广，无论是Web、Native、VR，甚至Shell应用都可以进行开发。这也是React的优势</p></blockquote><h4 id="React的缺点是什么"><a href="#React的缺点是什么" class="headerlink" title="React的缺点是什么"></a>React的缺点是什么</h4><blockquote><p>作为一个视图层的框架，React的缺点也十分明显。它并没有一整套完整的解决方案。在开发大型前端应用时，需要向社区寻找并整合解决方案。虽然一定程度上促进了社区的繁荣，但是也为开发者在技术选型和学习试用上造成了一定的成本。</p></blockquote><h3 id="项目实践—手写简易版React"><a href="#项目实践—手写简易版React" class="headerlink" title="项目实践—手写简易版React"></a>项目实践—手写简易版React</h3><p><img src="/img/react/reactDomFlow.jpg" alt="初始版react路程图"></p><h4 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h4><blockquote><ol><li>完成react的基本流程，vnode挂载到真实DOM</li><li>完成React的组件化</li></ol></blockquote><h4 id="前置知识–什么是JSX"><a href="#前置知识–什么是JSX" class="headerlink" title="前置知识–什么是JSX"></a>前置知识–什么是JSX</h4><blockquote><p>JSX是一个JavaScript的语法扩展，结构类似XML。<br>JSX主要用于声明React元素，但React中并不强制使用JSX。即使使用了JSX，也会在构建过程中，通过Babel插件编译为React.crateElement。所以JSX更像是React.createElement的一种语法糖。</p></blockquote><pre><code>let element = &lt;div&gt;hello world&lt;/div&gt;</code></pre><p>浏览器不能直接运行，需要工具进行编译<br>经过工作<a href="https://babeljs.io/repl" target="_blank" rel="noopener">babeljs.io/repl</a>转换后</p><pre><code>let element = React.createElement("div", null, "hello world")</code></pre><p>编译后的代码可以在浏览器中直接运行。但还需要其上下文环境</p><pre><code>var React = {}React.createElement = function () {}var element =  React.createElement("div", null, "hello world")</code></pre><p>这样即可以在浏览器环境下跑通了</p><p>以上只是在沙箱环境中进行的测试(直接拷贝)去运行的，如何真实开发一个react的呢？</p><ul><li>初始化环境</li><li>当前目录下运行<code>yarn init -y</code>，生成package.json</li><li>配置<code>babel</code>环境<pre><code>npm i -D @babel/core // 核心包npm i -D @babel/plugin-transform-react-jsx // jsx转换插件</code></pre></li><li>运行<code>yarn add parcel-bundler</code>，使用parcel进行打包。</li><li>创建index.HTML index.js文件<br>下面是我的文件目录</li></ul><p><img src="/img/react/folder.jpg" alt="文件目录"></p><p>在<code>package.json</code>文件中创建脚本命令<code>parcel public/index.html</code>方便我们运行。<br>运行结果如下图：<br><img src="/img/react/my-react1.jpg" alt="my-react"></p><p>把JXS写的复杂点</p><pre><code>const myReact = {}myReact.createElement = function () {  console.log(arguments)}const name = "tonghui"const handleBtn = () =&gt; {  console.log('handle button')}const element = (  &lt;div className="wrapper"&gt;    &lt;h1 className="title"&gt;hello {name}&lt;/h1&gt;    &lt;button className="s-btn" onClick={handleBtn}&gt;&lt;/button&gt;  &lt;/div&gt;)</code></pre><p>经过JSX插件转码后得到<br><img src="/img/react/my-react2.jpg" alt="my-react"><br>由上图得到，解析过程是一个递归过程，遇到子元素，再次执行MyReact.createElement<br>传给myReact.createElement中的参数</p><ul><li>标签</li><li>标签上的属性够成的对象</li><li>子元素</li></ul><p>执行myReact.createElement函数，JSX作为参数传递进去的是一个层次结构的JSON对象，这个对象就是虚拟DOM</p><h4 id="虚拟DOM渲染"><a href="#虚拟DOM渲染" class="headerlink" title="虚拟DOM渲染"></a>虚拟DOM渲染</h4><p><strong>思考</strong>：如何将虚拟DOM变成实体DOM</p><blockquote><p>因为根据vnode的结构，以及myReact.createElement是通过递归的方式被调用，我们也可以通过递归的方式，将vnode树给挂载到真实的DOM上。</p></blockquote><pre><code>/** * vnode转化为DOM方法 **/const render = (vnode, container) =&gt; {  if(typeof vnode === 'string') {    return container.appendChild(document.createTextNode(vnode))  }  if(typeof vnode === 'object') {    const dom = document.createElement(vnode.tag)    setAttribute(dom, vnode.attrs)    if (vnode.children &amp;&amp; Array.isArray(vnode.children)) {      vnode.children.forEach(vnodeChild =&gt; {        render(vnodeChild, dom)      })    }    container.appendChild(dom)  }}/** * 添加Dom中的属性 */const setAttribute = (dom, attrs) =&gt; {  for(let key in attrs) {    // 添加对事件绑定的处理    if (/^on/.test(key)) {      dom[key.toLocaleLowerCase()] = attrs[key]    } else if(key === 'style') {      Object.assign(dom.style, attrs[key])    } else {      dom[key] = attrs[key]    }  }}</code></pre><h4 id="封装MyRecat与MyReactDom"><a href="#封装MyRecat与MyReactDom" class="headerlink" title="封装MyRecat与MyReactDom"></a>封装MyRecat与MyReactDom</h4><p>myReac.js</p><pre><code>const createElement = function (tag, attrs, ...children) {  return {    tag,    attrs,    children  }}const myReact = {  createElement}export default myReact</code></pre><p>myReactDom.js</p><pre><code>/** * 添加Dom中的属性 */ const setAttribute = (dom, attrs) =&gt; {  for(let key in attrs) {    // 添加对事件绑定的处理    if (/^on/.test(key)) {      dom[key.toLocaleLowerCase()] = attrs[key]    } else if(key === 'style') {      Object.assign(dom.style, attrs[key])    } else {      dom[key] = attrs[key]    }  }}/** * vnode转化为DOM方法 **/ const render = (vnode, container) =&gt; {  if(typeof vnode === 'string') {    return container.appendChild(document.createTextNode(vnode))  }  if(typeof vnode === 'object') {    const dom = document.createElement(vnode.tag)    setAttribute(dom, vnode.attrs)    if (vnode.children &amp;&amp; Array.isArray(vnode.children)) {      vnode.children.forEach(vnodeChild =&gt; {        render(vnodeChild, dom)      })    }    container.appendChild(dom)  }}export default {  render}</code></pre><p><img src="/img/react/my-react3.png" alt="my-react"></p><h5 id="写一个测试计数器"><a href="#写一个测试计数器" class="headerlink" title="写一个测试计数器"></a>写一个测试计数器</h5><pre><code>let num = 0let timer = nulllet styleObj = {  color: 'red',  fontSize: '20px'}const onStart = () =&gt; {  num = num + 1  timer = setInterval(() =&gt; {    myReactDom.render(temp, document.querySelector('#app'))  }, 1000)}const onPause = () =&gt; {  clearInterval(timer)}const temp = (  &lt;div className="wrapper"&gt;    &lt;h1 style={styleObj}&gt;Number: {num}&lt;/h1&gt;    &lt;button onClick={onStart}&gt;start&lt;/button&gt;    &lt;button onClick={onPause}&gt;pause&lt;/button&gt;  &lt;/div&gt;)myReactDom.render(temp, document.querySelector('#app'))</code></pre><p>输出如下：<br><img src="/img/react/my-react4.png" alt="my-react"></p><h5 id="发现问题"><a href="#发现问题" class="headerlink" title="发现问题"></a>发现问题</h5><p>fix问题1：因为vnode除了是字符串，还有可能是数字，所以修改如下</p><pre><code>const render = (vnode, container) =&gt; {  if(['string', 'number'].includes(typeof vnode)) {    return container.appendChild(document.createTextNode(vnode))  }  ...</code></pre><p>fix问题2：在render时，删除之前挂载的dom</p><pre><code>const render = (vnode, container) =&gt; {  container.innerHTML = ''  _render(vnode, container)}</code></pre><p>结果：<br><img src="/img/react/my-react5.png" alt="my-react"></p><h4 id="MyReact的组件化"><a href="#MyReact的组件化" class="headerlink" title="MyReact的组件化"></a>MyReact的组件化</h4><p>实现下方写法：</p><pre><code>import MyReact from './lib/myReact'import MyReactDOM from './lib/myReactDom'class App extends MyReact.Component {  render () {    return (      &lt;h1&gt;hello tonghui&lt;/h1&gt;    )  }}</code></pre><p>对于自定义组件babel的转换</p><ul><li><p><code>&lt;App /&gt;</code> 得到myReact.createElement(App, null)</p></li><li><p><code>&lt;app&gt;hello&lt;/app&gt;</code>得到<code>myReact.createElement("app", null, "hello")</code></p><blockquote><p>因为JSX语法规定，只有首字母大写，才会被当作变量去处理。所以w我们用这个变量去创建一个对象，创建自己的组件。</p></blockquote><h6 id="完成Component对象，所有的组件都要继承这个对象创建"><a href="#完成Component对象，所有的组件都要继承这个对象创建" class="headerlink" title="完成Component对象，所有的组件都要继承这个对象创建"></a>完成Component对象，所有的组件都要继承这个对象创建</h6><pre><code>// myReact.jsclass Component {/** *  * @param {any} props 组件的入参  */constructor(props) {  this.props= props  this.state = {}  renderComponent()}}</code></pre></li></ul><p>function renderComponent() {<br>  console.log(‘renderComponent’)<br>}</p><pre><code>先构造一个复杂组件</code></pre><p>class App extends MyReact.Component {<br>  constructor(props) {<br>    super(props)<br>    this.state = {<br>      name: ‘tonghui’,<br>      job: ‘前端工程师’<br>    }<br>  }</p><p>  render() {<br>    const { name, job } = this.state<br>    return (<br>      </p><div classname="wrapper"><br>        <h1>hello {name}</h1><br>        <job job="{job}"><br>      </job></div><br>    )<br>  }<br>}<p></p><p>class Job extends MyReact.Component {<br>  render() {<br>    const { job } = this.props<br>    return (<br>      </p><div classname="job">我的工作是{job}</div><br>    )<br>  }<br>}<p></p><pre><code>**思考：** _render方法遇到myReact组件时，该如何处理呢？&gt; _render处理vnode，把vnode打印出来，发现App组件的tag是一个函数，所以渲染vnode时，根据这个函数，返回一个真实的DOM节点![my-react](/img/react/my-react6.jpg)myReactDom.js</code></pre><p> const _render = (vnode, container) =&gt; {<br>  …<br>  if(typeof vnode === ‘object’) {<br>    // 当vnode.tag是个函数时，代表这个时myReact组件<br>    if(typeof vnode.tag === ‘function’) {<br>      const dom = createComponent(vnode.tag, vnode.attrs)<br>      return container.appendChild(dom)<br>    }<br>    …<br>  }<br>}</p><pre><code>**思考：** createComponent方法如何设计，如何创造这个组件呢&gt; 我们的MyReact组件都由render方法，而且我们也拿到了组件的构造函数，所以都郭实例化对象，并调用render方法，从而得到组件</code></pre><p>/**</p><ul><li>@param {object} vnode element | MyReact |  string | number</li><li>@param {DOM} container element容器</li><li>/<br>const _render = (vnode, container) =&gt; {<br>const dom = createDomfromVnode(vnode)<br>container.appendChild(dom)<br>} </li></ul><p>/**</p><ul><li><p>vnode转化为DOM方法</p></li><li><p>*/<br>const createDomfromVnode = (vnode) =&gt; {<br>if([‘string’, ‘number’].includes(typeof vnode)) {<br>  return document.createTextNode(vnode)<br>}</p><p>if(typeof vnode === ‘object’) {<br>  // 当vnode.tag是个函数时，代表这个时myReact组件<br>  if(typeof vnode.tag === ‘function’) {</p><pre><code>return createComponent(vnode.tag, vnode.attrs)</code></pre><p>  }<br>  const dom = document.createElement(vnode.tag)<br>  setAttribute(dom, vnode.attrs)<br>  if (vnode.children &amp;&amp; Array.isArray(vnode.children)) {</p><pre><code>vnode.children.forEach(vnodeChild =&gt; {  _render(vnodeChild, dom)})</code></pre><p>  }<br>  return dom<br>}<br>}</p></li></ul><p>/**</p><ul><li>MyReact组件与DOM树转换</li><li>@param {function} constructor: 组件的构造函数 </li><li>@param {object} attrs： 参数</li><li>/<br>const createComponent = (constructor, attrs) =&gt; {<br>const component = new constructor(attrs)<br>//调用组件的render方法，得到组件对应的vnode<br>const vnode = component.render()<br>// vnode转换成真实DOM<br>const dom = createDomfromVnode(vnode)<br>// 方便组件中拿到真实的DOM<br>component.$root = dom<br>return dom<br>}<pre><code>完成后的UI展示效果：![my-react](/img/react/my-react7.jpg)</code></pre></li></ul><h4 id="完成function组件"><a href="#完成function组件" class="headerlink" title="完成function组件"></a>完成function组件</h4><p><strong>思考：</strong> function组件会有问题么，class本质也是一个function，只是一个function的语法糖</p><pre><code>class App extends MyReact.Component {  constructor(props) {    super(props)    this.state = {      name: 'tonghui',      job: '前端工程师',      hobby: '打游戏',    }  }  render() {    const { name, job, hobby } = this.state    return (      &lt;div className="wrapper"&gt;        &lt;h1&gt;hello {name}&lt;/h1&gt;        &lt;Hobby hobby={hobby} /&gt;      &lt;/div&gt;    )  }}const Hobby = (props) =&gt; {  const { hobby } = props || {}  return (    &lt;p&gt;我的爱好是{hobby}&lt;/p&gt;  )}</code></pre><p>报错如下：<br><img src="/img/react/react-error1.jpg" alt="react-error"><br><strong>解决方案：</strong></p><blockquote><p>虽然class组件本质也是函数，但是它继承了Component，所以可以通过 <code>xxx.prototype instanceof Component</code>     方法来进行判断</p></blockquote><pre><code>/** * myReact组件与DOM的转化 * @param {function} constructor: 组件的构造函数  * @param {object} attrs： 参数 */const createComponent = (constructor, attrs) =&gt; {  let component  if (constructor.prototype instanceof MyReact.Component) {    component = new constructor(attrs)  } else {    // 实例化组件,使得组件具有state, props    component = new MyReact.Component(attrs)    component.constructor = constructor    component.render = function () {      return this.constructor(attrs)    }  }  //调用组件的render方法，得到组件对应的vnode  const vnode = component.render()  // vnode转换成真实DOM  const dom = createDomfromVnode(vnode)  // 方便组件中拿到真实的DOM  component.$root = dom  return dom}</code></pre><blockquote><p><strong>回顾知识点：</strong></p><ol><li>prototype属性：原型属性，函数特殊有的属性，这个属性是一个指针，指向一个对象，这个对象就是包含所有实例共享的属性和方法即：原型对象</li><li>instanceof运算符：用于判断对象是否为某个构造函数的实例。</li></ol></blockquote><p>产品展示：<br><img src="/img/react/my-react8.jpg" alt="my-react"></p><h5 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h5><blockquote><p>本篇完结，下篇将MyReact组件的数据更新，父子组件的通信。 </p></blockquote><blockquote><p>本项目源码：<a href="https://github.com/tonghuitop/myReact" target="_blank" rel="noopener">https://github.com/tonghuitop/myReact</a> 由于项目后期将会继续完善，本博客源码将在react-init分支上。欢迎star。</p></blockquote><blockquote><p>项目借鉴：<a href="https://zhuanlan.zhihu.com/p/80570369" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/80570369</a> 博文</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> react </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> babel </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
